package com.astralplayer.nextplayer.gesture.error

import android.content.Context
import com.astralplayer.nextplayer.data.GestureAction
import com.astralplayer.nextplayer.data.gesture.EnhancedGestureSettings
import com.astralplayer.nextplayer.data.gesture.GestureType
import com.astralplayer.nextplayer.data.gesture.error.*
import io.mockk.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.*
import org.junit.Before
import org.junit.Test
import kotlin.test.*

class GestureErrorHandlingTest {
    
    private lateinit var context: Context
    private lateinit var errorHandler: GestureErrorHandler
    private lateinit var testScope: TestScope
    
    @Before
    fun setup() {
        context = mockk(relaxed = true)
        testScope = TestScope()
        errorHandler = GestureErrorHandler(context, testScope)
    }
    
    @Test
    fun `test error tracking and state updates`() = testScope.runTest {
        val error = GestureErrorHandler.GestureError(
            type = GestureErrorHandler.ErrorType.GESTURE_DETECTION_FAILED,
            message = "Test error",
            timestamp = System.currentTimeMillis()
        )
        
        errorHandler.handleError(error)
        advanceUntilIdle()
        
        val state = errorHandler.errorState.first()
        assertEquals(error, state.lastError)
        assertEquals(1, state.errorCount)
        assertFalse(state.isInSafeMode)
    }
    
    @Test
    fun `test error rate limiting triggers safe mode`() = testScope.runTest {
        // Generate many errors quickly
        repeat(12) { i ->
            val error = GestureErrorHandler.GestureError(
                type = GestureErrorHandler.ErrorType.GESTURE_DETECTION_FAILED,
                message = "Error $i",
                timestamp = System.currentTimeMillis()
            )
            errorHandler.handleError(error)
        }
        
        advanceTimeBy(11000) // Trigger monitoring
        advanceUntilIdle()
        
        val state = errorHandler.errorState.first()
        assertTrue(state.isInSafeMode, "Should enter safe mode after high error rate")
    }
    
    @Test
    fun `test recovery attempts`() = testScope.runTest {
        val error = GestureErrorHandler.GestureError(
            type = GestureErrorHandler.ErrorType.SETTINGS_CORRUPTION,
            message = "Settings corrupted",
            timestamp = System.currentTimeMillis()
        )
        
        var recoveryExecuted = false
        errorHandler.handleError(error) {
            recoveryExecuted = true
        }
        
        advanceUntilIdle()
        
        assertTrue(recoveryExecuted, "Recovery should be executed")
        val state = errorHandler.errorState.first()
        assertEquals(1, state.recoveryAttempts)
    }
    
    @Test
    fun `test max recovery attempts`() = testScope.runTest {
        val error = GestureErrorHandler.GestureError(
            type = GestureErrorHandler.ErrorType.PERFORMANCE_DEGRADATION,
            message = "Performance issue",
            timestamp = System.currentTimeMillis()
        )
        
        // Exhaust recovery attempts
        repeat(4) {
            errorHandler.handleError(error)
            advanceUntilIdle()
        }
        
        val state = errorHandler.errorState.first()
        assertTrue(state.recoveryAttempts >= 3)
        assertTrue(state.isInSafeMode, "Should enter safe mode after max recovery attempts")
    }
    
    @Test
    fun `test safe mode settings adaptation`() {
        val baseSettings = EnhancedGestureSettings()
        
        // Normal mode
        var adaptedSettings = errorHandler.getSafeModeSettings(baseSettings)
        assertEquals(baseSettings, adaptedSettings)
        
        // Enter safe mode
        errorHandler.handleError(
            GestureErrorHandler.GestureError(
                type = GestureErrorHandler.ErrorType.UNCAUGHT_EXCEPTION,
                message = "Critical error",
                timestamp = System.currentTimeMillis()
            )
        )
        
        testScope.advanceUntilIdle()
        
        // Safe mode settings should be limited
        adaptedSettings = errorHandler.getSafeModeSettings(baseSettings)
        assertTrue(
            adaptedSettings.general.sensitivity < baseSettings.general.sensitivity,
            "Sensitivity should be reduced in safe mode"
        )
        assertFalse(adaptedSettings.longPress.isEnabled, "Complex gestures should be disabled")
        assertFalse(adaptedSettings.pinchZoom.isEnabled, "Pinch zoom should be disabled")
    }
    
    @Test
    fun `test resilient gesture executor`() = testScope.runTest {
        val executor = ResilientGestureExecutor(errorHandler, testScope)
        
        // Successful execution
        val result = executor.executeGestureAction(
            GestureAction.Seek(1000L)
        ) {
            42
        }
        
        assertTrue(result.isSuccess)
        assertEquals(42, result.getOrNull())
        
        // Failed execution
        val failResult = executor.executeGestureAction(
            GestureAction.VolumeChange(0.5f)
        ) {
            throw RuntimeException("Test error")
        }
        
        assertTrue(failResult.isFailure)
        
        // Verify error was handled
        val state = errorHandler.errorState.first()
        assertNotNull(state.lastError)
    }
    
    @Test
    fun `test executor with retry`() = testScope.runTest {
        val executor = ResilientGestureExecutor(errorHandler, testScope)
        var attempts = 0
        
        val result = executor.executeWithRetry(
            maxRetries = 3,
            delayMs = 10
        ) {
            attempts++
            if (attempts < 3) {
                throw RuntimeException("Retry test")
            }
            "Success"
        }
        
        assertTrue(result.isSuccess)
        assertEquals("Success", result.getOrNull())
        assertEquals(3, attempts)
    }
    
    @Test
    fun `test gesture validation`() {
        // Valid inputs
        var validation = GestureValidator.validateGestureInput(
            GestureType.HORIZONTAL_SEEK,
            0.5f
        )
        assertTrue(validation is GestureValidator.ValidationResult.Valid)
        
        validation = GestureValidator.validateGestureInput(
            GestureType.VERTICAL_VOLUME,
            0.5f
        )
        assertTrue(validation is GestureValidator.ValidationResult.Valid)
        
        // Invalid inputs
        validation = GestureValidator.validateGestureInput(
            GestureType.HORIZONTAL_SEEK,
            Float.NaN
        )
        assertTrue(validation is GestureValidator.ValidationResult.Invalid)
        assertEquals("Invalid seek value", validation.reason)
        
        validation = GestureValidator.validateGestureInput(
            GestureType.VERTICAL_VOLUME,
            2.0f // Out of range
        )
        assertTrue(validation is GestureValidator.ValidationResult.Invalid)
        assertEquals("Volume delta out of range", validation.reason)
        
        validation = GestureValidator.validateGestureInput(
            GestureType.PINCH_ZOOM,
            15f // Too high
        )
        assertTrue(validation is GestureValidator.ValidationResult.Invalid)
        assertEquals("Zoom scale out of range", validation.reason)
    }
    
    @Test
    fun `test error context preservation`() = testScope.runTest {
        val contextData = mapOf(
            "gesture" to "horizontal_seek",
            "position" to "500,1000",
            "velocity" to "100.5"
        )
        
        val error = GestureErrorHandler.GestureError(
            type = GestureErrorHandler.ErrorType.GESTURE_DETECTION_FAILED,
            message = "Detection failed",
            timestamp = System.currentTimeMillis(),
            context = contextData
        )
        
        errorHandler.handleError(error)
        advanceUntilIdle()
        
        val state = errorHandler.errorState.first()
        assertEquals(contextData, state.lastError?.context)
    }
    
    @Test
    fun `test error handler reset`() = testScope.runTest {
        // Generate some errors
        repeat(5) {
            errorHandler.handleError(
                GestureErrorHandler.GestureError(
                    type = GestureErrorHandler.ErrorType.GESTURE_CONFLICT,
                    message = "Conflict $it",
                    timestamp = System.currentTimeMillis()
                )
            )
        }
        
        advanceUntilIdle()
        
        var state = errorHandler.errorState.first()
        assertTrue(state.errorCount > 0)
        
        // Reset
        errorHandler.resetErrorState()
        
        state = errorHandler.errorState.first()
        assertEquals(0, state.errorCount)
        assertNull(state.lastError)
        assertFalse(state.isInSafeMode)
    }
    
    @Test
    fun `test different error severities`() = testScope.runTest {
        val errorTypes = listOf(
            GestureErrorHandler.ErrorType.INVALID_INPUT to GestureErrorHandler.ErrorSeverity.LOW,
            GestureErrorHandler.ErrorType.GESTURE_CONFLICT to GestureErrorHandler.ErrorSeverity.LOW,
            GestureErrorHandler.ErrorType.GESTURE_DETECTION_FAILED to GestureErrorHandler.ErrorSeverity.MEDIUM,
            GestureErrorHandler.ErrorType.PERFORMANCE_DEGRADATION to GestureErrorHandler.ErrorSeverity.MEDIUM,
            GestureErrorHandler.ErrorType.SETTINGS_CORRUPTION to GestureErrorHandler.ErrorSeverity.HIGH,
            GestureErrorHandler.ErrorType.MEMORY_PRESSURE to GestureErrorHandler.ErrorSeverity.HIGH,
            GestureErrorHandler.ErrorType.UNCAUGHT_EXCEPTION to GestureErrorHandler.ErrorSeverity.CRITICAL,
            GestureErrorHandler.ErrorType.INITIALIZATION_FAILED to GestureErrorHandler.ErrorSeverity.CRITICAL
        )
        
        errorTypes.forEach { (type, expectedSeverity) ->
            assertEquals(
                expectedSeverity,
                type.severity,
                "Error type $type should have severity $expectedSeverity"
            )
        }
    }
}