package com.astralplayer.nextplayer.feature.playback

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.*
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.time.LocalDateTime
import java.time.ZoneId
import java.util.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "playback_schedule")

/**
 * Playback Scheduler
 * Manages scheduled playback of videos at specific times
 */
class PlaybackScheduler(
    private val context: Context
) {
    private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    private val json = Json { 
        ignoreUnknownKeys = true 
        prettyPrint = true
    }
    
    companion object {
        private const val ACTION_SCHEDULED_PLAYBACK = "com.astralplayer.nextplayer.SCHEDULED_PLAYBACK"
        private const val EXTRA_SCHEDULE_ID = "schedule_id"
        
        private val SCHEDULES_KEY = stringPreferencesKey("schedules")
    }
    
    /**
     * Schedule a video for playback at a specific time
     */
    suspend fun schedulePlayback(
        videoUri: String,
        videoTitle: String,
        scheduledTime: LocalDateTime,
        repeatMode: RepeatMode = RepeatMode.ONCE,
        enabled: Boolean = true
    ): String {
        val scheduleId = UUID.randomUUID().toString()
        
        val schedule = PlaybackSchedule(
            id = scheduleId,
            videoUri = videoUri,
            videoTitle = videoTitle,
            scheduledTime = scheduledTime.toString(),
            repeatMode = repeatMode,
            enabled = enabled,
            createdAt = System.currentTimeMillis()
        )
        
        // Save schedule
        saveSchedule(schedule)
        
        // Set alarm if enabled
        if (enabled) {
            setAlarm(schedule)
        }
        
        return scheduleId
    }
    
    /**
     * Update an existing schedule
     */
    suspend fun updateSchedule(
        scheduleId: String,
        scheduledTime: LocalDateTime? = null,
        repeatMode: RepeatMode? = null,
        enabled: Boolean? = null
    ) {
        val schedule = getSchedule(scheduleId) ?: return
        
        val updatedSchedule = schedule.copy(
            scheduledTime = scheduledTime?.toString() ?: schedule.scheduledTime,
            repeatMode = repeatMode ?: schedule.repeatMode,
            enabled = enabled ?: schedule.enabled
        )
        
        saveSchedule(updatedSchedule)
        
        // Update alarm
        cancelAlarm(scheduleId)
        if (updatedSchedule.enabled) {
            setAlarm(updatedSchedule)
        }
    }
    
    /**
     * Cancel a scheduled playback
     */
    suspend fun cancelSchedule(scheduleId: String) {
        removeSchedule(scheduleId)
        cancelAlarm(scheduleId)
    }
    
    /**
     * Get all schedules
     */
    fun getAllSchedules(): Flow<List<PlaybackSchedule>> {
        return context.dataStore.data.map { preferences ->
            val schedulesJson = preferences[SCHEDULES_KEY] ?: "[]"
            try {
                json.decodeFromString<List<PlaybackSchedule>>(schedulesJson)
            } catch (e: Exception) {
                emptyList()
            }
        }
    }
    
    /**
     * Get upcoming schedules
     */
    fun getUpcomingSchedules(): Flow<List<PlaybackSchedule>> {
        return getAllSchedules().map { schedules ->
            val now = LocalDateTime.now()
            schedules.filter { schedule ->
                schedule.enabled && 
                LocalDateTime.parse(schedule.scheduledTime).isAfter(now)
            }.sortedBy { it.scheduledTime }
        }
    }
    
    /**
     * Check and handle scheduled playback
     */
    suspend fun handleScheduledPlayback(scheduleId: String) {
        val schedule = getSchedule(scheduleId) ?: return
        
        // Launch video
        launchVideo(schedule.videoUri, schedule.videoTitle)
        
        // Handle repeat mode
        when (schedule.repeatMode) {
            RepeatMode.ONCE -> {
                // Remove one-time schedule
                removeSchedule(scheduleId)
            }
            RepeatMode.DAILY -> {
                // Reschedule for next day
                val nextTime = LocalDateTime.parse(schedule.scheduledTime).plusDays(1)
                updateSchedule(scheduleId, scheduledTime = nextTime)
            }
            RepeatMode.WEEKLY -> {
                // Reschedule for next week
                val nextTime = LocalDateTime.parse(schedule.scheduledTime).plusWeeks(1)
                updateSchedule(scheduleId, scheduledTime = nextTime)
            }
            RepeatMode.WEEKDAYS -> {
                // Reschedule for next weekday
                var nextTime = LocalDateTime.parse(schedule.scheduledTime).plusDays(1)
                while (nextTime.dayOfWeek.value > 5) { // Skip weekend
                    nextTime = nextTime.plusDays(1)
                }
                updateSchedule(scheduleId, scheduledTime = nextTime)
            }
            RepeatMode.WEEKENDS -> {
                // Reschedule for next weekend day
                var nextTime = LocalDateTime.parse(schedule.scheduledTime).plusDays(1)
                while (nextTime.dayOfWeek.value < 6) { // Skip weekdays
                    nextTime = nextTime.plusDays(1)
                }
                updateSchedule(scheduleId, scheduledTime = nextTime)
            }
        }
    }
    
    /**
     * Enable/disable all schedules
     */
    suspend fun setAllSchedulesEnabled(enabled: Boolean) {
        val schedules = getAllSchedulesSync()
        schedules.forEach { schedule ->
            updateSchedule(schedule.id, enabled = enabled)
        }
    }
    
    private suspend fun saveSchedule(schedule: PlaybackSchedule) {
        context.dataStore.edit { preferences ->
            val schedules = getAllSchedulesSync().toMutableList()
            schedules.removeAll { it.id == schedule.id }
            schedules.add(schedule)
            
            preferences[SCHEDULES_KEY] = json.encodeToString(schedules)
        }
    }
    
    private suspend fun removeSchedule(scheduleId: String) {
        context.dataStore.edit { preferences ->
            val schedules = getAllSchedulesSync().toMutableList()
            schedules.removeAll { it.id == scheduleId }
            
            preferences[SCHEDULES_KEY] = json.encodeToString(schedules)
        }
    }
    
    private suspend fun getSchedule(scheduleId: String): PlaybackSchedule? {
        return getAllSchedulesSync().find { it.id == scheduleId }
    }
    
    private suspend fun getAllSchedulesSync(): List<PlaybackSchedule> {
        val preferences = context.dataStore.data.map { it }.collect { it }
        val schedulesJson = preferences[SCHEDULES_KEY] ?: "[]"
        return try {
            json.decodeFromString(schedulesJson)
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    private fun setAlarm(schedule: PlaybackSchedule) {
        val intent = Intent(context, PlaybackScheduleReceiver::class.java).apply {
            action = ACTION_SCHEDULED_PLAYBACK
            putExtra(EXTRA_SCHEDULE_ID, schedule.id)
        }
        
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            schedule.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        val scheduledTime = LocalDateTime.parse(schedule.scheduledTime)
        val triggerTime = scheduledTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                triggerTime,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                triggerTime,
                pendingIntent
            )
        }
    }
    
    private fun cancelAlarm(scheduleId: String) {
        val intent = Intent(context, PlaybackScheduleReceiver::class.java).apply {
            action = ACTION_SCHEDULED_PLAYBACK
        }
        
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            scheduleId.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        alarmManager.cancel(pendingIntent)
    }
    
    private fun launchVideo(videoUri: String, videoTitle: String) {
        val intent = Intent(context, VideoPlayerActivity::class.java).apply {
            data = Uri.parse(videoUri)
            putExtra("video_title", videoTitle)
            putExtra("is_scheduled", true)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }
        context.startActivity(intent)
    }
}

/**
 * Data class for scheduled playback
 */
@Serializable
data class PlaybackSchedule(
    val id: String,
    val videoUri: String,
    val videoTitle: String,
    val scheduledTime: String, // ISO format
    val repeatMode: RepeatMode,
    val enabled: Boolean,
    val createdAt: Long
)

/**
 * Repeat modes for scheduled playback
 */
@Serializable
enum class RepeatMode {
    ONCE,
    DAILY,
    WEEKLY,
    WEEKDAYS,
    WEEKENDS
}