package com.astralplayer.nextplayer.analytics

import android.content.Context
import android.os.Bundle
// Firebase temporarily disabled for demo build
// import com.google.firebase.analytics.FirebaseAnalytics
// import com.google.firebase.analytics.ktx.analytics
// import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.serialization.Serializable
import java.util.concurrent.ConcurrentHashMap

/**
 * Feature Analytics Manager
 * Tracks usage and performance of new features
 */
class FeatureAnalytics(private val context: Context) {
    // private val firebaseAnalytics = Firebase.analytics // Firebase disabled for demo
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    // Local analytics storage for offline tracking
    private val analyticsCache = ConcurrentHashMap<String, MutableList<AnalyticsEvent>>()
    
    private val _analyticsEnabled = MutableStateFlow(true)
    val analyticsEnabled: StateFlow<Boolean> = _analyticsEnabled
    
    init {
        setupAnalytics()
    }
    
    private fun setupAnalytics() {
        // Enable analytics collection
        firebaseAnalytics.setAnalyticsCollectionEnabled(true)
        
        // Set user properties
        firebaseAnalytics.setUserProperty("app_version", getAppVersion())
        firebaseAnalytics.setUserProperty("device_type", getDeviceType())
    }
    
    // ============= SEARCH ANALYTICS =============
    
    fun trackSearchUsage(
        query: String,
        resultCount: Int,
        filterUsed: Boolean,
        searchDuration: Long
    ) {
        val params = Bundle().apply {
            putString("search_query", if (query.length > 50) query.take(50) else query)
            putInt("result_count", resultCount)
            putBoolean("filter_used", filterUsed)
            putLong("search_duration_ms", searchDuration)
            putString("feature_category", "advanced_search")
        }
        
        trackEvent("feature_search_used", params)
    }
    
    fun trackSearchFilter(
        filterType: String,
        filterValue: String,
        resultCount: Int
    ) {
        val params = Bundle().apply {
            putString("filter_type", filterType)
            putString("filter_value", filterValue)
            putInt("filtered_result_count", resultCount)
        }
        
        trackEvent("search_filter_applied", params)
    }
    
    fun trackSearchSuggestionUsed(
        suggestionText: String,
        suggestionType: String,
        position: Int
    ) {
        val params = Bundle().apply {
            putString("suggestion_text", suggestionText)
            putString("suggestion_type", suggestionType)
            putInt("suggestion_position", position)
        }
        
        trackEvent("search_suggestion_used", params)
    }
    
    // ============= AI SUBTITLE ANALYTICS =============
    
    fun trackSubtitleGeneration(
        videoDuration: Long,
        language: String,
        generationTime: Long,
        success: Boolean,
        errorReason: String? = null
    ) {
        val params = Bundle().apply {
            putLong("video_duration", videoDuration)
            putString("target_language", language)
            putLong("generation_time_ms", generationTime)
            putBoolean("generation_success", success)
            errorReason?.let { putString("error_reason", it) }
            putString("feature_category", "ai_subtitles")
        }
        
        trackEvent("subtitle_generation_completed", params)
    }
    
    fun trackSubtitleTranslation(
        fromLanguage: String,
        toLanguage: String,
        subtitleCount: Int,
        translationTime: Long,
        success: Boolean
    ) {
        val params = Bundle().apply {
            putString("from_language", fromLanguage)
            putString("to_language", toLanguage)
            putInt("subtitle_count", subtitleCount)
            putLong("translation_time_ms", translationTime)
            putBoolean("translation_success", success)
        }
        
        trackEvent("subtitle_translation_completed", params)
    }
    
    fun trackSubtitleCustomization(
        fontSize: Int,
        fontColor: String,
        backgroundColor: String,
        position: String
    ) {
        val params = Bundle().apply {
            putInt("font_size", fontSize)
            putString("font_color", fontColor)
            putString("background_color", backgroundColor)
            putString("subtitle_position", position)
        }
        
        trackEvent("subtitle_customization", params)
    }
    
    // ============= VOICE CONTROL ANALYTICS =============
    
    fun trackVoiceCommand(
        command: String,
        recognitionTime: Long,
        confidence: Float,
        success: Boolean,
        executionTime: Long? = null
    ) {
        val params = Bundle().apply {
            putString("voice_command", command)
            putLong("recognition_time_ms", recognitionTime)
            putFloat("recognition_confidence", confidence)
            putBoolean("command_success", success)
            executionTime?.let { putLong("execution_time_ms", it) }
            putString("feature_category", "voice_control")
        }
        
        trackEvent("voice_command_used", params)
    }
    
    fun trackVoiceControlSession(
        sessionDuration: Long,
        commandCount: Int,
        successfulCommands: Int,
        mode: String // "continuous" or "single"
    ) {
        val params = Bundle().apply {
            putLong("session_duration_ms", sessionDuration)
            putInt("total_commands", commandCount)
            putInt("successful_commands", successfulCommands)
            putString("voice_mode", mode)
            putFloat("success_rate", if (commandCount > 0) successfulCommands.toFloat() / commandCount else 0f)
        }
        
        trackEvent("voice_control_session_ended", params)
    }
    
    // ============= AUDIO EQUALIZER ANALYTICS =============
    
    fun trackEqualizerUsage(
        presetName: String,
        customSettings: Boolean,
        bassBoost: Int,
        virtualizerStrength: Int
    ) {
        val params = Bundle().apply {
            putString("equalizer_preset", presetName)
            putBoolean("custom_settings", customSettings)
            putInt("bass_boost_level", bassBoost)
            putInt("virtualizer_strength", virtualizerStrength)
            putString("feature_category", "audio_equalizer")
        }
        
        trackEvent("equalizer_settings_changed", params)
    }
    
    fun trackAudioEffectUsage(
        effectType: String,
        strength: Int,
        enabled: Boolean
    ) {
        val params = Bundle().apply {
            putString("audio_effect_type", effectType)
            putInt("effect_strength", strength)
            putBoolean("effect_enabled", enabled)
        }
        
        trackEvent("audio_effect_toggled", params)
    }
    
    // ============= SLEEP TIMER ANALYTICS =============
    
    fun trackSleepTimerUsage(
        duration: Long,
        fadeOutEnabled: Boolean,
        action: String, // "pause", "exit", "shutdown"
        completed: Boolean
    ) {
        val params = Bundle().apply {
            putLong("timer_duration_ms", duration)
            putBoolean("fade_out_enabled", fadeOutEnabled)
            putString("timer_action", action)
            putBoolean("timer_completed", completed)
            putString("feature_category", "sleep_timer")
        }
        
        trackEvent("sleep_timer_used", params)
    }
    
    // ============= BOOKMARK ANALYTICS =============
    
    fun trackBookmarkUsage(
        action: String, // "add", "remove", "navigate"
        bookmarkType: String, // "manual", "auto", "chapter"
        videoPosition: Long,
        videoDuration: Long
    ) {
        val params = Bundle().apply {
            putString("bookmark_action", action)
            putString("bookmark_type", bookmarkType)
            putLong("video_position", videoPosition)
            putLong("video_duration", videoDuration)
            putFloat("position_percentage", if (videoDuration > 0) videoPosition.toFloat() / videoDuration else 0f)
            putString("feature_category", "video_bookmarks")
        }
        
        trackEvent("bookmark_action", params)
    }
    
    // ============= PERFORMANCE ANALYTICS =============
    
    fun trackPerformanceOptimization(
        qualityPreset: String,
        batteryMode: Boolean,
        dataSaver: Boolean,
        cacheSize: Long,
        memoryUsage: Int
    ) {
        val params = Bundle().apply {
            putString("quality_preset", qualityPreset)
            putBoolean("battery_optimization", batteryMode)
            putBoolean("data_saver_mode", dataSaver)
            putLong("cache_size_bytes", cacheSize)
            putInt("memory_usage_percent", memoryUsage)
            putString("feature_category", "performance")
        }
        
        trackEvent("performance_settings_changed", params)
    }
    
    fun trackCacheManagement(
        action: String, // "clear", "optimize"
        sizeBefore: Long,
        sizeAfter: Long,
        itemsCleared: Int
    ) {
        val params = Bundle().apply {
            putString("cache_action", action)
            putLong("size_before_bytes", sizeBefore)
            putLong("size_after_bytes", sizeAfter)
            putInt("items_cleared", itemsCleared)
            putLong("space_freed_bytes", sizeBefore - sizeAfter)
        }
        
        trackEvent("cache_management", params)
    }
    
    // ============= SOCIAL SHARING ANALYTICS =============
    
    fun trackSharingUsage(
        shareType: String, // "link", "file", "preview"
        contentType: String, // "video", "playlist", "moment"
        platform: String,
        success: Boolean
    ) {
        val params = Bundle().apply {
            putString("share_type", shareType)
            putString("content_type", contentType)
            putString("target_platform", platform)
            putBoolean("share_success", success)
            putString("feature_category", "social_sharing")
        }
        
        trackEvent("content_shared", params)
    }
    
    fun trackCollaborativePlaylist(
        action: String, // "create", "join", "edit"
        playlistSize: Int,
        collaboratorCount: Int,
        permissions: String
    ) {
        val params = Bundle().apply {
            putString("playlist_action", action)
            putInt("playlist_size", playlistSize)
            putInt("collaborator_count", collaboratorCount)
            putString("playlist_permissions", permissions)
        }
        
        trackEvent("collaborative_playlist_action", params)
    }
    
    // ============= FEATURE USAGE ANALYTICS =============
    
    fun trackFeatureDiscovery(
        featureName: String,
        discoveryMethod: String, // "menu", "gesture", "voice", "search"
        timeToDiscover: Long? = null
    ) {
        val params = Bundle().apply {
            putString("feature_name", featureName)
            putString("discovery_method", discoveryMethod)
            timeToDiscover?.let { putLong("time_to_discover_ms", it) }
        }
        
        trackEvent("feature_discovered", params)
    }
    
    fun trackFeatureAdoption(
        featureName: String,
        firstUse: Boolean,
        sessionUsageCount: Int,
        totalUsageCount: Int
    ) {
        val params = Bundle().apply {
            putString("feature_name", featureName)
            putBoolean("first_use", firstUse)
            putInt("session_usage_count", sessionUsageCount)
            putInt("total_usage_count", totalUsageCount)
        }
        
        trackEvent("feature_adoption", params)
    }
    
    fun trackFeatureAbandon(
        featureName: String,
        timeSpent: Long,
        reason: String, // "error", "complexity", "not_useful", "other"
        completedAction: Boolean
    ) {
        val params = Bundle().apply {
            putString("feature_name", featureName)
            putLong("time_spent_ms", timeSpent)
            putString("abandon_reason", reason)
            putBoolean("completed_action", completedAction)
        }
        
        trackEvent("feature_abandoned", params)
    }
    
    // ============= ERROR TRACKING =============
    
    fun trackFeatureError(
        featureName: String,
        errorType: String,
        errorMessage: String,
        stackTrace: String? = null
    ) {
        val params = Bundle().apply {
            putString("feature_name", featureName)
            putString("error_type", errorType)
            putString("error_message", errorMessage.take(100)) // Limit message length
            stackTrace?.let { putString("stack_trace", it.take(500)) }
        }
        
        trackEvent("feature_error", params)
    }
    
    // ============= USER BEHAVIOR ANALYTICS =============
    
    fun trackUserJourney(
        startFeature: String,
        endFeature: String,
        pathTaken: List<String>,
        journeyDuration: Long
    ) {
        val params = Bundle().apply {
            putString("journey_start", startFeature)
            putString("journey_end", endFeature)
            putString("journey_path", pathTaken.joinToString(" -> "))
            putLong("journey_duration_ms", journeyDuration)
            putInt("journey_steps", pathTaken.size)
        }
        
        trackEvent("user_journey", params)
    }
    
    fun trackEngagementMetrics(
        sessionDuration: Long,
        featuresUsed: List<String>,
        videosWatched: Int,
        interactionCount: Int
    ) {
        val params = Bundle().apply {
            putLong("session_duration_ms", sessionDuration)
            putString("features_used", featuresUsed.joinToString(","))
            putInt("videos_watched", videosWatched)
            putInt("interaction_count", interactionCount)
            putInt("unique_features_used", featuresUsed.distinct().size)
        }
        
        trackEvent("engagement_session", params)
    }
    
    // ============= CORE TRACKING METHODS =============
    
    private fun trackEvent(eventName: String, params: Bundle) {
        if (!_analyticsEnabled.value) return
        
        scope.launch {
            try {
                // Track with Firebase
                firebaseAnalytics.logEvent(eventName, params)
                
                // Cache locally for offline analytics
                cacheEventLocally(eventName, params)
                
            } catch (e: Exception) {
                // Log error but don't crash the app
                android.util.Log.e("FeatureAnalytics", "Failed to track event: $eventName", e)
            }
        }
    }
    
    private fun cacheEventLocally(eventName: String, params: Bundle) {
        val event = AnalyticsEvent(
            name = eventName,
            parameters = bundleToMap(params),
            timestamp = System.currentTimeMillis()
        )
        
        analyticsCache.getOrPut(eventName) { mutableListOf() }.add(event)
        
        // Limit cache size per event type
        analyticsCache[eventName]?.let { events ->
            if (events.size > 100) {
                events.removeAt(0) // Remove oldest
            }
        }
    }
    
    private fun bundleToMap(bundle: Bundle): Map<String, Any> {
        val map = mutableMapOf<String, Any>()
        bundle.keySet().forEach { key ->
            bundle.get(key)?.let { value ->
                map[key] = value
            }
        }
        return map
    }
    
    fun enableAnalytics(enabled: Boolean) {
        _analyticsEnabled.value = enabled
        firebaseAnalytics.setAnalyticsCollectionEnabled(enabled)
    }
    
    fun getLocalAnalytics(): Map<String, List<AnalyticsEvent>> {
        return analyticsCache.toMap()
    }
    
    fun clearLocalAnalytics() {
        analyticsCache.clear()
    }
    
    private fun getAppVersion(): String {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            packageInfo.versionName ?: "unknown"
        } catch (e: Exception) {
            "unknown"
        }
    }
    
    private fun getDeviceType(): String {
        return if (context.resources.configuration.smallestScreenWidthDp >= 600) {
            "tablet"
        } else {
            "phone"
        }
    }
    
    fun release() {
        scope.cancel()
    }
}

@Serializable
data class AnalyticsEvent(
    val name: String,
    val parameters: Map<String, Any>,
    val timestamp: Long
)