package com.astralplayer.nextplayer.data.repository

import com.astralplayer.nextplayer.data.database.PlaylistDao
import com.astralplayer.nextplayer.data.database.PlaylistEntity
import com.astralplayer.nextplayer.data.database.PlaylistItemEntity
import com.astralplayer.nextplayer.data.database.RecentFileEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.util.UUID

interface PlaylistRepository {
    fun getAllPlaylists(): Flow<List<Playlist>>
    suspend fun createPlaylist(name: String, description: String = ""): String
    suspend fun deletePlaylist(playlistId: String)
    suspend fun updatePlaylist(playlist: Playlist)
    suspend fun getPlaylist(playlistId: String): Playlist?
    fun getPlaylistVideos(playlistId: String): Flow<List<PlaylistVideo>>
    suspend fun addVideoToPlaylist(playlistId: String, videoUri: String, videoTitle: String)
    suspend fun removeVideoFromPlaylist(playlistId: String, videoId: String)
    suspend fun getPlaylistVideoCount(playlistId: String): Int
    suspend fun moveVideoUp(playlistId: String, videoId: String)
    suspend fun moveVideoDown(playlistId: String, videoId: String)
    suspend fun moveVideoToPosition(playlistId: String, videoId: String, newPosition: Int)
}

data class Playlist(
    val id: String,
    val name: String,
    val description: String = "",
    val createdTime: Long = System.currentTimeMillis(),
    val updatedTime: Long = System.currentTimeMillis(),
    val thumbnailPath: String? = null,
    val isAutoGenerated: Boolean = false,
    val sortOrder: Int = 0
)

data class PlaylistVideo(
    val id: String,
    val uri: String,
    val title: String,
    val duration: Long,
    val thumbnailPath: String? = null
)

class PlaylistRepositoryImpl(
    private val playlistDao: PlaylistDao
) : PlaylistRepository {
    
    override fun getAllPlaylists(): Flow<List<Playlist>> {
        return playlistDao.getAllPlaylists().map { entities ->
            entities.map { entity ->
                Playlist(
                    id = entity.id,
                    name = entity.name,
                    description = entity.description,
                    createdTime = entity.createdTime,
                    updatedTime = entity.updatedTime,
                    thumbnailPath = entity.thumbnailPath,
                    isAutoGenerated = entity.isAutoGenerated,
                    sortOrder = entity.sortOrder
                )
            }
        }
    }
    
    override suspend fun createPlaylist(name: String, description: String): String {
        val playlistId = UUID.randomUUID().toString()
        val entity = PlaylistEntity(
            id = playlistId,
            name = name,
            description = description,
            createdTime = System.currentTimeMillis(),
            updatedTime = System.currentTimeMillis()
        )
        playlistDao.insertPlaylist(entity)
        return playlistId
    }
    
    override suspend fun deletePlaylist(playlistId: String) {
        playlistDao.getPlaylistById(playlistId)?.let {
            playlistDao.deletePlaylist(it)
        }
    }
    
    override suspend fun updatePlaylist(playlist: Playlist) {
        val entity = PlaylistEntity(
            id = playlist.id,
            name = playlist.name,
            description = playlist.description,
            createdTime = playlist.createdTime,
            updatedTime = System.currentTimeMillis(),
            thumbnailPath = playlist.thumbnailPath,
            isAutoGenerated = playlist.isAutoGenerated,
            sortOrder = playlist.sortOrder
        )
        playlistDao.updatePlaylist(entity)
    }
    
    override suspend fun getPlaylist(playlistId: String): Playlist? {
        return playlistDao.getPlaylistById(playlistId)?.let { entity ->
            Playlist(
                id = entity.id,
                name = entity.name,
                description = entity.description,
                createdTime = entity.createdTime,
                updatedTime = entity.updatedTime,
                thumbnailPath = entity.thumbnailPath,
                isAutoGenerated = entity.isAutoGenerated,
                sortOrder = entity.sortOrder
            )
        }
    }
    
    override fun getPlaylistVideos(playlistId: String): Flow<List<PlaylistVideo>> {
        return playlistDao.getPlaylistFiles(playlistId).map { entities ->
            entities.map { entity ->
                PlaylistVideo(
                    id = entity.id,
                    uri = entity.uri,
                    title = entity.title,
                    duration = entity.duration,
                    thumbnailPath = entity.thumbnailPath
                )
            }
        }
    }
    
    override suspend fun addVideoToPlaylist(playlistId: String, videoUri: String, videoTitle: String) {
        val itemId = UUID.randomUUID().toString()
        val position = playlistDao.getPlaylistItemCount(playlistId)
        
        // First ensure the video exists in recent_files
        val fileId = videoUri.hashCode().toString()
        
        val item = PlaylistItemEntity(
            id = itemId,
            playlistId = playlistId,
            fileId = fileId,
            position = position,
            addedTime = System.currentTimeMillis()
        )
        playlistDao.insertPlaylistItem(item)
        
        // Update playlist updated time
        playlistDao.getPlaylistById(playlistId)?.let { playlist ->
            playlistDao.updatePlaylist(
                playlist.copy(updatedTime = System.currentTimeMillis())
            )
        }
    }
    
    override suspend fun removeVideoFromPlaylist(playlistId: String, videoId: String) {
        playlistDao.removePlaylistItem(playlistId, videoId)
        
        // Update playlist updated time
        playlistDao.getPlaylistById(playlistId)?.let { playlist ->
            playlistDao.updatePlaylist(
                playlist.copy(updatedTime = System.currentTimeMillis())
            )
        }
    }
    
    override suspend fun getPlaylistVideoCount(playlistId: String): Int {
        return playlistDao.getPlaylistItemCount(playlistId)
    }
    
    override suspend fun moveVideoUp(playlistId: String, videoId: String) {
        val currentPosition = playlistDao.getVideoPosition(playlistId, videoId) ?: return
        if (currentPosition > 0) {
            moveVideoToPosition(playlistId, videoId, currentPosition - 1)
        }
    }
    
    override suspend fun moveVideoDown(playlistId: String, videoId: String) {
        val currentPosition = playlistDao.getVideoPosition(playlistId, videoId) ?: return
        val totalVideos = playlistDao.getPlaylistItemCount(playlistId)
        if (currentPosition < totalVideos - 1) {
            moveVideoToPosition(playlistId, videoId, currentPosition + 1)
        }
    }
    
    override suspend fun moveVideoToPosition(playlistId: String, videoId: String, newPosition: Int) {
        val currentPosition = playlistDao.getVideoPosition(playlistId, videoId) ?: return
        
        if (currentPosition == newPosition) return
        
        if (currentPosition < newPosition) {
            // Moving down: shift items up to fill the gap
            playlistDao.shiftPositionsUp(playlistId, currentPosition, newPosition)
        } else {
            // Moving up: shift items down to make space
            playlistDao.shiftPositionsDown(playlistId, newPosition, currentPosition)
        }
        
        // Update the video's position
        playlistDao.updateVideoPosition(playlistId, videoId, newPosition)
        
        // Update playlist updated time
        playlistDao.getPlaylistById(playlistId)?.let { playlist ->
            playlistDao.updatePlaylist(
                playlist.copy(updatedTime = System.currentTimeMillis())
            )
        }
    }
}