package com.astralplayer.nextplayer.utils

import android.content.Context
import android.media.MediaMetadataRetriever
import android.net.Uri
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import kotlin.math.roundToInt

/**
 * Analyzes video content to detect type and recommend optimal playback speed
 */
class VideoTypeAnalyzer(private val context: Context) {
    
    companion object {
        private const val TAG = "VideoTypeAnalyzer"
        
        // Video type thresholds
        private const val MIN_DURATION_SECONDS = 10
        private const val MUSIC_VIDEO_MAX_DURATION = 600 // 10 minutes
        private const val TUTORIAL_MIN_DURATION = 300 // 5 minutes
        private const val MOVIE_MIN_DURATION = 3600 // 1 hour
        
        // Frame rate categories
        private const val LOW_FPS = 15
        private const val STANDARD_FPS = 30
        private const val HIGH_FPS = 60
        
        // Speed recommendations by video type
        private val SPEED_RECOMMENDATIONS = mapOf(
            VideoType.MUSIC_VIDEO to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.75f,
                maxSpeed = 1.25f,
                reason = "Music videos are best enjoyed at normal speed"
            ),
            VideoType.TUTORIAL to SpeedRecommendation(
                defaultSpeed = 1.5f,
                minSpeed = 1.0f,
                maxSpeed = 2.0f,
                reason = "Tutorials can often be watched faster while still understanding content"
            ),
            VideoType.LECTURE to SpeedRecommendation(
                defaultSpeed = 1.75f,
                minSpeed = 1.25f,
                maxSpeed = 2.5f,
                reason = "Lectures typically have slower speech that can be sped up"
            ),
            VideoType.PODCAST to SpeedRecommendation(
                defaultSpeed = 1.5f,
                minSpeed = 1.0f,
                maxSpeed = 2.0f,
                reason = "Podcasts are often conversational and can be sped up comfortably"
            ),
            VideoType.MOVIE to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.9f,
                maxSpeed = 1.1f,
                reason = "Movies are crafted for specific pacing and timing"
            ),
            VideoType.TV_SHOW to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.9f,
                maxSpeed = 1.25f,
                reason = "TV shows are designed for normal playback speed"
            ),
            VideoType.ANIMATION to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.75f,
                maxSpeed = 1.5f,
                reason = "Animations may have rapid action that's hard to follow at high speeds"
            ),
            VideoType.SPORTS to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.5f,
                maxSpeed = 2.0f,
                reason = "Sports content varies - slow for replays, fast for downtime"
            ),
            VideoType.NEWS to SpeedRecommendation(
                defaultSpeed = 1.25f,
                minSpeed = 1.0f,
                maxSpeed = 1.75f,
                reason = "News content is often informational and can be consumed faster"
            ),
            VideoType.DOCUMENTARY to SpeedRecommendation(
                defaultSpeed = 1.25f,
                minSpeed = 1.0f,
                maxSpeed = 1.5f,
                reason = "Documentaries balance information with visual storytelling"
            ),
            VideoType.SHORT_FORM to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.75f,
                maxSpeed = 2.0f,
                reason = "Short videos vary widely in content type"
            ),
            VideoType.UNKNOWN to SpeedRecommendation(
                defaultSpeed = 1.0f,
                minSpeed = 0.25f,
                maxSpeed = 8.0f,
                reason = "Adjust speed for your preference"
            )
        )
    }
    
    /**
     * Analyze video and return type with metadata
     */
    suspend fun analyzeVideo(videoUri: Uri): VideoAnalysis = withContext(Dispatchers.IO) {
        try {
            val metadata = extractVideoMetadata(videoUri)
            val videoType = detectVideoType(videoUri, metadata)
            val recommendation = SPEED_RECOMMENDATIONS[videoType] ?: SPEED_RECOMMENDATIONS[VideoType.UNKNOWN]!!
            
            VideoAnalysis(
                videoType = videoType,
                metadata = metadata,
                recommendation = recommendation,
                confidence = calculateConfidence(videoType, metadata)
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to analyze video", e)
            VideoAnalysis(
                videoType = VideoType.UNKNOWN,
                metadata = VideoMetadata(),
                recommendation = SPEED_RECOMMENDATIONS[VideoType.UNKNOWN]!!,
                confidence = 0f
            )
        }
    }
    
    /**
     * Extract video metadata using MediaMetadataRetriever
     */
    private suspend fun extractVideoMetadata(videoUri: Uri): VideoMetadata = withContext(Dispatchers.IO) {
        val retriever = MediaMetadataRetriever()
        try {
            when (videoUri.scheme) {
                "content", "file" -> retriever.setDataSource(context, videoUri)
                "http", "https" -> retriever.setDataSource(videoUri.toString(), HashMap())
                else -> throw IllegalArgumentException("Unsupported URI scheme: ${videoUri.scheme}")
            }
            
            val duration = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)?.toLongOrNull() ?: 0L
            val width = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)?.toIntOrNull() ?: 0
            val height = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)?.toIntOrNull() ?: 0
            val frameRate = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_CAPTURE_FRAMERATE)?.toFloatOrNull() ?: 0f
            val bitrate = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE)?.toIntOrNull() ?: 0
            val hasAudio = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_AUDIO) == "yes"
            val mimeType = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_MIMETYPE) ?: ""
            
            // Extract filename from URI
            val filename = extractFilename(videoUri)
            
            VideoMetadata(
                duration = duration,
                width = width,
                height = height,
                frameRate = frameRate,
                bitrate = bitrate,
                hasAudio = hasAudio,
                mimeType = mimeType,
                filename = filename,
                aspectRatio = if (height > 0) width.toFloat() / height else 0f
            )
        } finally {
            retriever.release()
        }
    }
    
    /**
     * Detect video type using metadata and content analysis
     */
    private fun detectVideoType(videoUri: Uri, metadata: VideoMetadata): VideoType {
        // Check filename patterns first
        val filename = metadata.filename.lowercase()
        
        // Music video patterns
        if (filename.contains("music") || filename.contains("mv") || 
            filename.contains("official") || filename.contains("lyric")) {
            if (metadata.duration < MUSIC_VIDEO_MAX_DURATION * 1000) {
                return VideoType.MUSIC_VIDEO
            }
        }
        
        // Tutorial patterns
        if (filename.contains("tutorial") || filename.contains("howto") || 
            filename.contains("guide") || filename.contains("lesson")) {
            return VideoType.TUTORIAL
        }
        
        // Lecture patterns
        if (filename.contains("lecture") || filename.contains("class") || 
            filename.contains("course") || filename.contains("education")) {
            return VideoType.LECTURE
        }
        
        // Podcast patterns
        if (filename.contains("podcast") || filename.contains("episode") ||
            (metadata.hasAudio && metadata.frameRate < LOW_FPS)) {
            return VideoType.PODCAST
        }
        
        // Sports patterns
        if (filename.contains("sport") || filename.contains("game") || 
            filename.contains("match") || filename.contains("race")) {
            return VideoType.SPORTS
        }
        
        // News patterns
        if (filename.contains("news") || filename.contains("report") || 
            filename.contains("breaking")) {
            return VideoType.NEWS
        }
        
        // Documentary patterns
        if (filename.contains("documentary") || filename.contains("docu")) {
            return VideoType.DOCUMENTARY
        }
        
        // Duration-based detection
        val durationSeconds = metadata.duration / 1000
        
        // Short form content (< 1 minute)
        if (durationSeconds < 60) {
            return VideoType.SHORT_FORM
        }
        
        // Movie detection (> 1 hour, high quality)
        if (durationSeconds > MOVIE_MIN_DURATION && metadata.width >= 1280) {
            return VideoType.MOVIE
        }
        
        // TV show detection (20-60 minutes)
        if (durationSeconds in 1200..3600) {
            return VideoType.TV_SHOW
        }
        
        // Animation detection using frame rate and patterns
        if (filename.contains("anime") || filename.contains("cartoon") || 
            filename.contains("animation")) {
            return VideoType.ANIMATION
        }
        
        // Tutorial detection by duration
        if (durationSeconds > TUTORIAL_MIN_DURATION && durationSeconds < MOVIE_MIN_DURATION) {
            return VideoType.TUTORIAL
        }
        
        return VideoType.UNKNOWN
    }
    
    /**
     * Calculate confidence score for the detection
     */
    private fun calculateConfidence(videoType: VideoType, metadata: VideoMetadata): Float {
        var confidence = 0.5f // Base confidence
        
        // Increase confidence with metadata quality
        if (metadata.duration > 0) confidence += 0.1f
        if (metadata.width > 0 && metadata.height > 0) confidence += 0.1f
        if (metadata.frameRate > 0) confidence += 0.1f
        if (metadata.filename.isNotEmpty()) confidence += 0.1f
        
        // Adjust for video type specificity
        when (videoType) {
            VideoType.UNKNOWN -> confidence *= 0.5f
            VideoType.SHORT_FORM -> confidence *= 0.8f
            else -> confidence *= 1.0f
        }
        
        return confidence.coerceIn(0f, 1f)
    }
    
    /**
     * Extract filename from URI
     */
    private fun extractFilename(uri: Uri): String {
        return try {
            when (uri.scheme) {
                "file" -> File(uri.path ?: "").name
                "content" -> {
                    // Try to get display name from content resolver
                    uri.lastPathSegment ?: ""
                }
                else -> uri.lastPathSegment ?: ""
            }
        } catch (e: Exception) {
            ""
        }
    }
}

/**
 * Video types that can be detected
 */
enum class VideoType {
    MUSIC_VIDEO,
    TUTORIAL,
    LECTURE,
    PODCAST,
    MOVIE,
    TV_SHOW,
    ANIMATION,
    SPORTS,
    NEWS,
    DOCUMENTARY,
    SHORT_FORM,
    UNKNOWN
}

/**
 * Video metadata extracted from file
 */
data class VideoMetadata(
    val duration: Long = 0, // milliseconds
    val width: Int = 0,
    val height: Int = 0,
    val frameRate: Float = 0f,
    val bitrate: Int = 0,
    val hasAudio: Boolean = true,
    val mimeType: String = "",
    val filename: String = "",
    val aspectRatio: Float = 0f
)

/**
 * Speed recommendation for a video type
 */
data class SpeedRecommendation(
    val defaultSpeed: Float,
    val minSpeed: Float,
    val maxSpeed: Float,
    val reason: String
)

/**
 * Complete video analysis result
 */
data class VideoAnalysis(
    val videoType: VideoType,
    val metadata: VideoMetadata,
    val recommendation: SpeedRecommendation,
    val confidence: Float
)