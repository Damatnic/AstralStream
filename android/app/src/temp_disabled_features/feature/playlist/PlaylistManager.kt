package com.astralplayer.nextplayer.feature.playlist

import android.content.Context
import android.net.Uri
import androidx.compose.foundation.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import java.text.SimpleDateFormat
import java.util.*

data class PlaylistItem(
    val id: String,
    val title: String,
    val uri: String,
    val duration: Long,
    val thumbnailPath: String? = null,
    val addedAt: Long = System.currentTimeMillis(),
    val playCount: Int = 0,
    val lastPlayedAt: Long = 0L
)

data class Playlist(
    val id: String,
    val name: String,
    val description: String = "",
    val items: List<PlaylistItem> = emptyList(),
    val createdAt: Long = System.currentTimeMillis(),
    val lastModified: Long = System.currentTimeMillis(),
    val thumbnailPath: String? = null,
    val isAutoGenerated: Boolean = false,
    val playlistType: PlaylistType = PlaylistType.CUSTOM
)

enum class PlaylistType {
    CUSTOM,
    RECENTLY_PLAYED,
    MOST_PLAYED,
    FAVORITES,
    WATCH_LATER,
    RECENTLY_ADDED
}

data class PlaylistStats(
    val totalDuration: Long,
    val totalItems: Int,
    val totalPlayCount: Int,
    val averageRating: Float,
    val lastPlayedItem: PlaylistItem? = null
)

class PlaylistManager(private val context: Context) {
    
    private val _playlists = MutableStateFlow<List<Playlist>>(emptyList())
    val playlists: StateFlow<List<Playlist>> = _playlists.asStateFlow()
    
    private val _currentPlaylist = MutableStateFlow<Playlist?>(null)
    val currentPlaylist: StateFlow<Playlist?> = _currentPlaylist.asStateFlow()
    
    private val _currentPlayingItem = MutableStateFlow<PlaylistItem?>(null)
    val currentPlayingItem: StateFlow<PlaylistItem?> = _currentPlayingItem.asStateFlow()
    
    private val _isShuffleEnabled = MutableStateFlow(false)
    val isShuffleEnabled: StateFlow<Boolean> = _isShuffleEnabled.asStateFlow()
    
    private val _repeatMode = MutableStateFlow(RepeatMode.OFF)
    val repeatMode: StateFlow<RepeatMode> = _repeatMode.asStateFlow()
    
    private val _playlistError = MutableStateFlow<String?>(null)
    val playlistError: StateFlow<String?> = _playlistError.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    enum class RepeatMode {
        OFF, ONE, ALL
    }

    init {
        loadDefaultPlaylists()
    }

    private fun loadDefaultPlaylists() {
        _isLoading.value = true
        
        val defaultPlaylists = listOf(
            createRecentlyPlayedPlaylist(),
            createMostPlayedPlaylist(),
            createFavoritesPlaylist(),
            createWatchLaterPlaylist(),
            createRecentlyAddedPlaylist(),
            createSampleCustomPlaylist()
        )
        
        _playlists.value = defaultPlaylists
        _isLoading.value = false
    }

    private fun createRecentlyPlayedPlaylist(): Playlist {
        val recentItems = generateSampleItems().take(10)
        return Playlist(
            id = "recently_played",
            name = "Recently Played",
            description = "Your recently watched videos",
            items = recentItems,
            isAutoGenerated = true,
            playlistType = PlaylistType.RECENTLY_PLAYED
        )
    }

    private fun createMostPlayedPlaylist(): Playlist {
        val mostPlayedItems = generateSampleItems().take(15)
        return Playlist(
            id = "most_played",
            name = "Most Played",
            description = "Your most watched videos",
            items = mostPlayedItems,
            isAutoGenerated = true,
            playlistType = PlaylistType.MOST_PLAYED
        )
    }

    private fun createFavoritesPlaylist(): Playlist {
        val favoriteItems = generateSampleItems().take(8)
        return Playlist(
            id = "favorites",
            name = "Favorites",
            description = "Your favorite videos",
            items = favoriteItems,
            isAutoGenerated = true,
            playlistType = PlaylistType.FAVORITES
        )
    }

    private fun createWatchLaterPlaylist(): Playlist {
        val watchLaterItems = generateSampleItems().take(12)
        return Playlist(
            id = "watch_later",
            name = "Watch Later",
            description = "Videos saved for later viewing",
            items = watchLaterItems,
            isAutoGenerated = true,
            playlistType = PlaylistType.WATCH_LATER
        )
    }

    private fun createRecentlyAddedPlaylist(): Playlist {
        val recentlyAddedItems = generateSampleItems().take(20)
        return Playlist(
            id = "recently_added",
            name = "Recently Added",
            description = "Recently added videos to your library",
            items = recentlyAddedItems,
            isAutoGenerated = true,
            playlistType = PlaylistType.RECENTLY_ADDED
        )
    }

    private fun createSampleCustomPlaylist(): Playlist {
        val customItems = generateSampleItems().take(6)
        return Playlist(
            id = "my_playlist_1",
            name = "My Awesome Playlist",
            description = "A custom playlist with my favorite content",
            items = customItems,
            playlistType = PlaylistType.CUSTOM
        )
    }

    private fun generateSampleItems(): List<PlaylistItem> {
        val sampleTitles = listOf(
            "Epic Movie Trailer", "Documentary: Space Exploration", "Music Video: Cosmic Journey",
            "Tutorial: Video Editing", "Comedy Sketch", "Nature Documentary",
            "Tech Review: Latest Gadgets", "Travel Vlog: Japan", "Cooking Show: Italian Cuisine",
            "Workout Video: Full Body", "Meditation Guide", "News Update",
            "Gaming Stream Highlights", "Art Tutorial: Digital Painting", "Science Experiment",
            "Concert Performance", "Interview: Celebrity", "Short Film: Drama",
            "Educational: History", "Sports Highlights"
        )
        
        return sampleTitles.mapIndexed { index, title ->
            PlaylistItem(
                id = "item_$index",
                title = title,
                uri = "content://media/external/video/media/${1000 + index}",
                duration = (60000L..7200000L).random(), // 1 minute to 2 hours
                playCount = (0..50).random(),
                lastPlayedAt = System.currentTimeMillis() - (0..7 * 24 * 60 * 60 * 1000L).random()
            )
        }
    }

    fun createPlaylist(name: String, description: String = ""): Playlist {
        val newPlaylist = Playlist(
            id = "playlist_${System.currentTimeMillis()}",
            name = name,
            description = description,
            playlistType = PlaylistType.CUSTOM
        )
        
        _playlists.value = _playlists.value + newPlaylist
        return newPlaylist
    }

    fun deletePlaylist(playlistId: String) {
        _playlists.value = _playlists.value.filter { it.id != playlistId }
        if (_currentPlaylist.value?.id == playlistId) {
            _currentPlaylist.value = null
        }
    }

    fun updatePlaylist(updatedPlaylist: Playlist) {
        _playlists.value = _playlists.value.map { playlist ->
            if (playlist.id == updatedPlaylist.id) {
                updatedPlaylist.copy(lastModified = System.currentTimeMillis())
            } else {
                playlist
            }
        }
        
        if (_currentPlaylist.value?.id == updatedPlaylist.id) {
            _currentPlaylist.value = updatedPlaylist
        }
    }

    fun addItemToPlaylist(playlistId: String, item: PlaylistItem) {
        _playlists.value = _playlists.value.map { playlist ->
            if (playlist.id == playlistId) {
                playlist.copy(
                    items = playlist.items + item,
                    lastModified = System.currentTimeMillis()
                )
            } else {
                playlist
            }
        }
    }

    fun removeItemFromPlaylist(playlistId: String, itemId: String) {
        _playlists.value = _playlists.value.map { playlist ->
            if (playlist.id == playlistId) {
                playlist.copy(
                    items = playlist.items.filter { it.id != itemId },
                    lastModified = System.currentTimeMillis()
                )
            } else {
                playlist
            }
        }
    }

    fun reorderPlaylistItems(playlistId: String, fromIndex: Int, toIndex: Int) {
        _playlists.value = _playlists.value.map { playlist ->
            if (playlist.id == playlistId) {
                val newItems = playlist.items.toMutableList()
                val item = newItems.removeAt(fromIndex)
                newItems.add(toIndex, item)
                playlist.copy(
                    items = newItems,
                    lastModified = System.currentTimeMillis()
                )
            } else {
                playlist
            }
        }
    }

    fun setCurrentPlaylist(playlist: Playlist) {
        _currentPlaylist.value = playlist
    }

    fun playItem(item: PlaylistItem) {
        _currentPlayingItem.value = item
        // Update play count
        _currentPlaylist.value?.let { playlist ->
            val updatedItems = playlist.items.map { playlistItem ->
                if (playlistItem.id == item.id) {
                    playlistItem.copy(
                        playCount = playlistItem.playCount + 1,
                        lastPlayedAt = System.currentTimeMillis()
                    )
                } else {
                    playlistItem
                }
            }
            updatePlaylist(playlist.copy(items = updatedItems))
        }
    }

    fun playNext() {
        _currentPlaylist.value?.let { playlist ->
            _currentPlayingItem.value?.let { currentItem ->
                val currentIndex = playlist.items.indexOfFirst { it.id == currentItem.id }
                if (currentIndex != -1) {
                    val nextIndex = when {
                        _isShuffleEnabled.value -> playlist.items.indices.random()
                        currentIndex < playlist.items.size - 1 -> currentIndex + 1
                        _repeatMode.value == RepeatMode.ALL -> 0
                        else -> currentIndex
                    }
                    if (nextIndex != currentIndex || _repeatMode.value == RepeatMode.ONE) {
                        playItem(playlist.items[nextIndex])
                    }
                }
            }
        }
    }

    fun playPrevious() {
        _currentPlaylist.value?.let { playlist ->
            _currentPlayingItem.value?.let { currentItem ->
                val currentIndex = playlist.items.indexOfFirst { it.id == currentItem.id }
                if (currentIndex != -1) {
                    val previousIndex = when {
                        _isShuffleEnabled.value -> playlist.items.indices.random()
                        currentIndex > 0 -> currentIndex - 1
                        _repeatMode.value == RepeatMode.ALL -> playlist.items.size - 1
                        else -> currentIndex
                    }
                    if (previousIndex != currentIndex || _repeatMode.value == RepeatMode.ONE) {
                        playItem(playlist.items[previousIndex])
                    }
                }
            }
        }
    }

    fun toggleShuffle() {
        _isShuffleEnabled.value = !_isShuffleEnabled.value
    }

    fun toggleRepeatMode() {
        _repeatMode.value = when (_repeatMode.value) {
            RepeatMode.OFF -> RepeatMode.ONE
            RepeatMode.ONE -> RepeatMode.ALL
            RepeatMode.ALL -> RepeatMode.OFF
        }
    }

    fun getPlaylistStats(playlist: Playlist): PlaylistStats {
        return PlaylistStats(
            totalDuration = playlist.items.sumOf { it.duration },
            totalItems = playlist.items.size,
            totalPlayCount = playlist.items.sumOf { it.playCount },
            averageRating = 4.2f, // Mock rating
            lastPlayedItem = playlist.items.maxByOrNull { it.lastPlayedAt }
        )
    }

    fun searchInPlaylist(playlistId: String, query: String): List<PlaylistItem> {
        return _playlists.value.find { it.id == playlistId }?.items?.filter {
            it.title.contains(query, ignoreCase = true)
        } ?: emptyList()
    }

    fun clearError() {
        _playlistError.value = null
    }
}

class PlaylistViewModel(private val playlistManager: PlaylistManager) : ViewModel() {
    
    val playlists = playlistManager.playlists
    val currentPlaylist = playlistManager.currentPlaylist
    val currentPlayingItem = playlistManager.currentPlayingItem
    val isShuffleEnabled = playlistManager.isShuffleEnabled
    val repeatMode = playlistManager.repeatMode
    val playlistError = playlistManager.playlistError
    val isLoading = playlistManager.isLoading

    fun createPlaylist(name: String, description: String = "") {
        viewModelScope.launch {
            playlistManager.createPlaylist(name, description)
        }
    }

    fun deletePlaylist(playlistId: String) {
        viewModelScope.launch {
            playlistManager.deletePlaylist(playlistId)
        }
    }

    fun updatePlaylist(playlist: Playlist) {
        viewModelScope.launch {
            playlistManager.updatePlaylist(playlist)
        }
    }

    fun addItemToPlaylist(playlistId: String, item: PlaylistItem) {
        viewModelScope.launch {
            playlistManager.addItemToPlaylist(playlistId, item)
        }
    }

    fun removeItemFromPlaylist(playlistId: String, itemId: String) {
        viewModelScope.launch {
            playlistManager.removeItemFromPlaylist(playlistId, itemId)
        }
    }

    fun setCurrentPlaylist(playlist: Playlist) {
        playlistManager.setCurrentPlaylist(playlist)
    }

    fun playItem(item: PlaylistItem) {
        playlistManager.playItem(item)
    }

    fun playNext() {
        playlistManager.playNext()
    }

    fun playPrevious() {
        playlistManager.playPrevious()
    }

    fun toggleShuffle() {
        playlistManager.toggleShuffle()
    }

    fun toggleRepeatMode() {
        playlistManager.toggleRepeatMode()
    }

    fun getPlaylistStats(playlist: Playlist): PlaylistStats {
        return playlistManager.getPlaylistStats(playlist)
    }

    fun clearError() {
        playlistManager.clearError()
    }
}

@Composable
fun PlaylistManagementScreen(
    playlists: List<Playlist>,
    currentPlaylist: Playlist?,
    isLoading: Boolean,
    playlistError: String?,
    onPlaylistSelected: (Playlist) -> Unit,
    onCreatePlaylist: () -> Unit,
    onEditPlaylist: (Playlist) -> Unit,
    onDeletePlaylist: (String) -> Unit,
    onClearError: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Playlists",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold
            )
            
            IconButton(onClick = onCreatePlaylist) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Create Playlist"
                )
            }
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Error handling
        playlistError?.let { error ->
            ErrorCard(
                error = error,
                onDismiss = onClearError
            )
            Spacer(modifier = Modifier.height(16.dp))
        }
        
        // Loading state
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxWidth(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            // Playlists grid
            LazyColumn(
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(playlists) { playlist ->
                    PlaylistCard(
                        playlist = playlist,
                        isSelected = playlist.id == currentPlaylist?.id,
                        onClick = { onPlaylistSelected(playlist) },
                        onEdit = { onEditPlaylist(playlist) },
                        onDelete = { onDeletePlaylist(playlist.id) }
                    )
                }
            }
        }
    }
}

@Composable
fun PlaylistCard(
    playlist: Playlist,
    isSelected: Boolean,
    onClick: () -> Unit,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) 
                MaterialTheme.colorScheme.primaryContainer 
            else 
                MaterialTheme.colorScheme.surface
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = playlist.name,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                    
                    if (playlist.description.isNotEmpty()) {
                        Text(
                            text = playlist.description,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = "${playlist.items.size} videos",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        
                        val totalDuration = playlist.items.sumOf { it.duration }
                        Text(
                            text = formatDuration(totalDuration),
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                
                if (!playlist.isAutoGenerated) {
                    Row {
                        IconButton(onClick = onEdit) {
                            Icon(
                                imageVector = Icons.Default.Edit,
                                contentDescription = "Edit Playlist",
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                        
                        IconButton(onClick = onDelete) {
                            Icon(
                                imageVector = Icons.Default.Delete,
                                contentDescription = "Delete Playlist",
                                tint = MaterialTheme.colorScheme.error
                            )
                        }
                    }
                }
            }
            
            // Playlist type indicator
            if (playlist.isAutoGenerated) {
                Spacer(modifier = Modifier.height(8.dp))
                Surface(
                    color = MaterialTheme.colorScheme.secondaryContainer,
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        text = "Auto-generated",
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.onSecondaryContainer
                    )
                }
            }
        }
    }
}

@Composable
fun ErrorCard(error: String, onDismiss: () -> Unit) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.errorContainer
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Row(
                modifier = Modifier.weight(1f),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.Error,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = error,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
            }
            
            IconButton(onClick = onDismiss) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Dismiss",
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        }
    }
}

fun formatDuration(millis: Long): String {
    val seconds = millis / 1000
    val hours = seconds / 3600
    val minutes = (seconds % 3600) / 60
    
    return when {
        hours > 0 -> String.format("%d:%02d:%02d", hours, minutes, seconds % 60)
        else -> String.format("%d:%02d", minutes, seconds % 60)
    }
}