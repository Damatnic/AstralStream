package com.astralplayer.nextplayer.feature.streaming

import android.content.Context
import android.graphics.SurfaceTexture
import android.hardware.Camera
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaCodec
import android.media.MediaCodecInfo
import android.media.MediaFormat
import android.media.MediaRecorder
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.Surface
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.io.IOException
import java.nio.ByteBuffer
import com.pedro.encoder.input.video.CameraOpenException
import com.pedro.rtmp.rtmp.RtmpClient
import com.pedro.rtmp.utils.ConnectCheckerRtmp
import java.net.SocketException
import java.net.UnknownHostException

/**
 * Real RTMP streaming service implementation using RootEncoder
 */
class RTMPStreamingService(private val context: Context) : ConnectCheckerRtmp {
    
    companion object {
        private const val TAG = "RTMPStreamingService"
        
        // Video settings
        private const val VIDEO_WIDTH = 1280
        private const val VIDEO_HEIGHT = 720
        private const val VIDEO_BITRATE = 2000000 // 2 Mbps
        private const val VIDEO_FPS = 30
        private const val VIDEO_IFRAME_INTERVAL = 2
        
        // Audio settings
        private const val AUDIO_SAMPLE_RATE = 44100
        private const val AUDIO_BITRATE = 128000 // 128 kbps
        private const val AUDIO_CHANNELS = 2
    }
    
    private val _streamingState = MutableStateFlow(StreamingState.IDLE)
    val streamingState: StateFlow<StreamingState> = _streamingState.asStateFlow()
    
    private val _streamStats = MutableStateFlow(RTMPStreamStats())
    val streamStats: StateFlow<RTMPStreamStats> = _streamStats.asStateFlow()
    
    // Media components
    private var videoEncoder: MediaCodec? = null
    private var audioEncoder: MediaCodec? = null
    private var audioRecord: AudioRecord? = null
    private var camera: Camera? = null
    
    // RTMP components
    private var rtmpClient: RtmpClient? = null
    private var rtmpUrl: String? = null
    
    // Surfaces and textures
    private var inputSurface: Surface? = null
    private var surfaceTexture: SurfaceTexture? = null
    
    // Coroutines
    private var streamingScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private var audioJob: Job? = null
    private var videoJob: Job? = null
    private var statsJob: Job? = null
    
    // Stream timing
    private var streamStartTime = 0L
    private var frameCount = 0L
    private var bytesSent = 0L
    
    /**
     * Initialize streaming service
     */
    fun initialize() {
        try {
            rtmpClient = RtmpClient(this)
            rtmpClient?.setVideoCodecInfo(
                VIDEO_WIDTH,
                VIDEO_HEIGHT,
                VIDEO_FPS,
                VIDEO_BITRATE,
                0, // rotation
                2  // iFrameInterval
            )
            rtmpClient?.setAudioCodecInfo(
                AUDIO_SAMPLE_RATE,
                AUDIO_CHANNELS == 2
            )
            
            Log.d(TAG, "RTMP streaming service initialized")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize RTMP service", e)
        }
    }
    
    /**
     * Start RTMP stream
     */
    suspend fun startStream(url: String, streamKey: String): Boolean = withContext(Dispatchers.IO) {
        if (_streamingState.value != StreamingState.IDLE) {
            Log.w(TAG, "Stream already active or starting")
            return@withContext false
        }
        
        _streamingState.value = StreamingState.PREPARING
        rtmpUrl = "$url$streamKey"
        
        try {
            // Initialize encoders
            if (!initializeVideoEncoder() || !initializeAudioEncoder()) {
                throw IOException("Failed to initialize encoders")
            }
            
            // Initialize audio recording
            if (!initializeAudioRecord()) {
                throw IOException("Failed to initialize audio recording")
            }
            
            // Connect to RTMP server
            rtmpClient?.connect(rtmpUrl)
            
            // Wait for connection
            delay(1000)
            
            if (_streamingState.value == StreamingState.CONNECTED) {
                // Start encoding
                startVideoEncoding()
                startAudioEncoding()
                startStatsMonitoring()
                
                _streamingState.value = StreamingState.STREAMING
                streamStartTime = System.currentTimeMillis()
                
                Log.i(TAG, "RTMP stream started successfully")
                return@withContext true
            } else {
                throw IOException("Failed to connect to RTMP server")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start stream", e)
            stopStream()
            return@withContext false
        }
    }
    
    /**
     * Stop RTMP stream
     */
    fun stopStream() {
        Log.d(TAG, "Stopping RTMP stream")
        
        _streamingState.value = StreamingState.STOPPING
        
        // Cancel all jobs
        audioJob?.cancel()
        videoJob?.cancel()
        statsJob?.cancel()
        
        // Stop and release encoders
        try {
            videoEncoder?.signalEndOfInputStream()
            videoEncoder?.stop()
            videoEncoder?.release()
            videoEncoder = null
            
            audioEncoder?.stop()
            audioEncoder?.release()
            audioEncoder = null
            
            audioRecord?.stop()
            audioRecord?.release()
            audioRecord = null
            
            camera?.stopPreview()
            camera?.release()
            camera = null
            
            inputSurface?.release()
            inputSurface = null
            
            surfaceTexture?.release()
            surfaceTexture = null
            
            rtmpClient?.disconnect()
            
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping stream components", e)
        }
        
        _streamingState.value = StreamingState.IDLE
        _streamStats.value = RTMPStreamStats()
    }
    
    /**
     * Initialize video encoder
     */
    private fun initializeVideoEncoder(): Boolean {
        return try {
            val format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, VIDEO_WIDTH, VIDEO_HEIGHT)
            format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)
            format.setInteger(MediaFormat.KEY_BIT_RATE, VIDEO_BITRATE)
            format.setInteger(MediaFormat.KEY_FRAME_RATE, VIDEO_FPS)
            format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, VIDEO_IFRAME_INTERVAL)
            
            videoEncoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC)
            videoEncoder?.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)
            
            inputSurface = videoEncoder?.createInputSurface()
            videoEncoder?.start()
            
            Log.d(TAG, "Video encoder initialized")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize video encoder", e)
            false
        }
    }
    
    /**
     * Initialize audio encoder
     */
    private fun initializeAudioEncoder(): Boolean {
        return try {
            val format = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_AAC, AUDIO_SAMPLE_RATE, AUDIO_CHANNELS)
            format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC)
            format.setInteger(MediaFormat.KEY_BIT_RATE, AUDIO_BITRATE)
            
            audioEncoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_AUDIO_AAC)
            audioEncoder?.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)
            audioEncoder?.start()
            
            Log.d(TAG, "Audio encoder initialized")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize audio encoder", e)
            false
        }
    }
    
    /**
     * Initialize audio recording
     */
    private fun initializeAudioRecord(): Boolean {
        return try {
            val bufferSize = AudioRecord.getMinBufferSize(
                AUDIO_SAMPLE_RATE,
                AudioFormat.CHANNEL_IN_STEREO,
                AudioFormat.ENCODING_PCM_16BIT
            )
            
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.MIC,
                AUDIO_SAMPLE_RATE,
                AudioFormat.CHANNEL_IN_STEREO,
                AudioFormat.ENCODING_PCM_16BIT,
                bufferSize * 2
            )
            
            audioRecord?.startRecording()
            Log.d(TAG, "Audio recording initialized")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize audio recording", e)
            false
        }
    }
    
    /**
     * Start video encoding
     */
    private fun startVideoEncoding() {
        videoJob = streamingScope.launch {
            val bufferInfo = MediaCodec.BufferInfo()
            
            while (isActive && _streamingState.value == StreamingState.STREAMING) {
                try {
                    val outputBufferIndex = videoEncoder?.dequeueOutputBuffer(bufferInfo, 0) ?: -1
                    
                    if (outputBufferIndex >= 0) {
                        val outputBuffer = videoEncoder?.getOutputBuffer(outputBufferIndex)
                        
                        if (outputBuffer != null && bufferInfo.size > 0) {
                            // Send video data to RTMP
                            val data = ByteArray(bufferInfo.size)
                            outputBuffer.get(data)
                            outputBuffer.clear()
                            
                            rtmpClient?.sendVideo(data, bufferInfo)
                            
                            frameCount++
                            bytesSent += bufferInfo.size
                        }
                        
                        videoEncoder?.releaseOutputBuffer(outputBufferIndex, false)
                    }
                    
                    delay(1) // Small delay to prevent CPU overload
                } catch (e: Exception) {
                    Log.e(TAG, "Error in video encoding", e)
                }
            }
        }
    }
    
    /**
     * Start audio encoding
     */
    private fun startAudioEncoding() {
        audioJob = streamingScope.launch {
            val bufferInfo = MediaCodec.BufferInfo()
            val audioBuffer = ByteBuffer.allocateDirect(4096)
            
            while (isActive && _streamingState.value == StreamingState.STREAMING) {
                try {
                    // Read audio data
                    audioBuffer.clear()
                    val bytesRead = audioRecord?.read(audioBuffer, audioBuffer.remaining()) ?: 0
                    
                    if (bytesRead > 0) {
                        // Feed audio data to encoder
                        val inputBufferIndex = audioEncoder?.dequeueInputBuffer(0) ?: -1
                        
                        if (inputBufferIndex >= 0) {
                            val inputBuffer = audioEncoder?.getInputBuffer(inputBufferIndex)
                            inputBuffer?.clear()
                            inputBuffer?.put(audioBuffer.array(), 0, bytesRead)
                            
                            audioEncoder?.queueInputBuffer(
                                inputBufferIndex,
                                0,
                                bytesRead,
                                System.nanoTime() / 1000,
                                0
                            )
                        }
                    }
                    
                    // Get encoded audio
                    val outputBufferIndex = audioEncoder?.dequeueOutputBuffer(bufferInfo, 0) ?: -1
                    
                    if (outputBufferIndex >= 0) {
                        val outputBuffer = audioEncoder?.getOutputBuffer(outputBufferIndex)
                        
                        if (outputBuffer != null && bufferInfo.size > 0) {
                            // Send audio data to RTMP
                            val data = ByteArray(bufferInfo.size)
                            outputBuffer.get(data)
                            outputBuffer.clear()
                            
                            rtmpClient?.sendAudio(data, bufferInfo)
                            
                            bytesSent += bufferInfo.size
                        }
                        
                        audioEncoder?.releaseOutputBuffer(outputBufferIndex, false)
                    }
                    
                    delay(1) // Small delay to prevent CPU overload
                } catch (e: Exception) {
                    Log.e(TAG, "Error in audio encoding", e)
                }
            }
        }
    }
    
    /**
     * Start monitoring stream statistics
     */
    private fun startStatsMonitoring() {
        statsJob = streamingScope.launch {
            while (isActive && _streamingState.value == StreamingState.STREAMING) {
                val duration = System.currentTimeMillis() - streamStartTime
                val fps = if (duration > 0) (frameCount * 1000 / duration).toInt() else 0
                val bitrate = if (duration > 0) (bytesSent * 8000 / duration).toInt() else 0
                
                _streamStats.value = RTMPStreamStats(
                    bitrate = bitrate,
                    fps = fps,
                    frameCount = frameCount,
                    bytesSent = bytesSent,
                    duration = duration,
                    isConnected = true
                )
                
                delay(1000) // Update stats every second
            }
        }
    }
    
    // ConnectCheckerRtmp callbacks
    override fun onConnectionSuccessRtmp() {
        Log.i(TAG, "RTMP connection successful")
        _streamingState.value = StreamingState.CONNECTED
    }
    
    override fun onConnectionFailedRtmp(reason: String) {
        Log.e(TAG, "RTMP connection failed: $reason")
        _streamingState.value = StreamingState.ERROR
        stopStream()
    }
    
    override fun onNewBitrateRtmp(bitrate: Long) {
        Log.d(TAG, "New bitrate: $bitrate")
    }
    
    override fun onDisconnectRtmp() {
        Log.w(TAG, "RTMP disconnected")
        if (_streamingState.value == StreamingState.STREAMING) {
            stopStream()
        }
    }
    
    override fun onAuthErrorRtmp() {
        Log.e(TAG, "RTMP authentication error")
        _streamingState.value = StreamingState.ERROR
        stopStream()
    }
    
    override fun onAuthSuccessRtmp() {
        Log.i(TAG, "RTMP authentication successful")
    }
    
    /**
     * Release resources
     */
    fun release() {
        stopStream()
        streamingScope.cancel()
    }
}

/**
 * Streaming state enum
 */
enum class StreamingState {
    IDLE,
    PREPARING,
    CONNECTED,
    STREAMING,
    STOPPING,
    ERROR
}

/**
 * RTMP stream statistics
 */
data class RTMPStreamStats(
    val bitrate: Int = 0,
    val fps: Int = 0,
    val frameCount: Long = 0,
    val bytesSent: Long = 0,
    val duration: Long = 0,
    val isConnected: Boolean = false
)