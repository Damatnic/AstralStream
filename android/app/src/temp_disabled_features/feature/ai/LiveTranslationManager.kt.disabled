package com.astralplayer.nextplayer.feature.ai

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.util.Log
// import com.google.mlkit.common.model.DownloadConditions // Temporarily disabled
// import com.google.mlkit.nl.translate.* // Temporarily disabled
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.*
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

/**
 * Real-time translation manager for live audio
 */
class LiveTranslationManager(private val context: Context) {
    
    private val claudeAI = ClaudeAIService(context)
    
    companion object {
        private const val TAG = "LiveTranslationManager"
        private const val RECOGNITION_INTERVAL_MS = 2000L
    }
    
    private val _isTranslating = MutableStateFlow(false)
    val isTranslating: StateFlow<Boolean> = _isTranslating.asStateFlow()
    
    private val _currentTranslation = MutableStateFlow<TranslationResult?>(null)
    val currentTranslation: StateFlow<TranslationResult?> = _currentTranslation.asStateFlow()
    
    private val _translationHistory = MutableStateFlow<List<TranslationResult>>(emptyList())
    val translationHistory: StateFlow<List<TranslationResult>> = _translationHistory.asStateFlow()
    
    private val _sourceLanguage = MutableStateFlow("auto")
    val sourceLanguage: StateFlow<String> = _sourceLanguage.asStateFlow()
    
    private val _targetLanguage = MutableStateFlow("en")
    val targetLanguage: StateFlow<String> = _targetLanguage.asStateFlow()
    
    private var speechRecognizer: SpeechRecognizer? = null
    private var currentTranslator: Translator? = null
    private var translationJob: Job? = null
    private var recognitionActive = false
    
    private val availableLanguages = mapOf(
        "en" to TranslateLanguage.ENGLISH,
        "es" to TranslateLanguage.SPANISH,
        "fr" to TranslateLanguage.FRENCH,
        "de" to TranslateLanguage.GERMAN,
        "it" to TranslateLanguage.ITALIAN,
        "pt" to TranslateLanguage.PORTUGUESE,
        "ru" to TranslateLanguage.RUSSIAN,
        "zh" to TranslateLanguage.CHINESE,
        "ja" to TranslateLanguage.JAPANESE,
        "ko" to TranslateLanguage.KOREAN,
        "ar" to TranslateLanguage.ARABIC,
        "hi" to TranslateLanguage.HINDI
    )
    
    init {
        if (SpeechRecognizer.isRecognitionAvailable(context)) {
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)
        } else {
            Log.e(TAG, "Speech recognition not available")
        }
    }
    
    /**
     * Start live translation from audio
     */
    suspend fun startLiveTranslation(
        sourceLanguageCode: String = "auto",
        targetLanguageCode: String = "en"
    ): Boolean {
        if (_isTranslating.value) return true
        
        _sourceLanguage.value = sourceLanguageCode
        _targetLanguage.value = targetLanguageCode
        
        // Set up translator
        val targetLang = availableLanguages[targetLanguageCode] ?: TranslateLanguage.ENGLISH
        val sourceLang = if (sourceLanguageCode == "auto") {
            TranslateLanguage.ENGLISH // Default, will be detected
        } else {
            availableLanguages[sourceLanguageCode] ?: TranslateLanguage.ENGLISH
        }
        
        val options = TranslatorOptions.Builder()
            .setSourceLanguage(sourceLang)
            .setTargetLanguage(targetLang)
            .build()
        
        currentTranslator = Translation.getClient(options)
        
        // Download translation model if needed
        val downloadConditions = DownloadConditions.Builder()
            .requireWifi()
            .build()
        
        return try {
            currentTranslator?.downloadModelIfNeeded(downloadConditions)?.await()
            _isTranslating.value = true
            startContinuousRecognition()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to download translation model", e)
            false
        }
    }
    
    /**
     * Stop live translation
     */
    fun stopLiveTranslation() {
        _isTranslating.value = false
        recognitionActive = false
        translationJob?.cancel()
        speechRecognizer?.stopListening()
        speechRecognizer?.cancel()
    }
    
    /**
     * Start continuous speech recognition
     */
    private fun startContinuousRecognition() {
        translationJob = CoroutineScope(Dispatchers.Main).launch {
            while (_isTranslating.value) {
                if (!recognitionActive) {
                    startRecognitionCycle()
                }
                delay(RECOGNITION_INTERVAL_MS)
            }
        }
    }
    
    /**
     * Start a single recognition cycle
     */
    private fun startRecognitionCycle() {
        val recognizerIntent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
            
            // Set source language if specified
            if (_sourceLanguage.value != "auto") {
                putExtra(RecognizerIntent.EXTRA_LANGUAGE, getLocaleForLanguage(_sourceLanguage.value))
            }
        }
        
        recognitionActive = true
        
        speechRecognizer?.setRecognitionListener(object : RecognitionListener {
            override fun onReadyForSpeech(params: Bundle?) {
                Log.d(TAG, "Ready for speech")
            }
            
            override fun onBeginningOfSpeech() {
                Log.d(TAG, "Speech started")
            }
            
            override fun onRmsChanged(rmsdB: Float) {
                // Audio level changed
            }
            
            override fun onBufferReceived(buffer: ByteArray?) {
                // Buffer received
            }
            
            override fun onEndOfSpeech() {
                Log.d(TAG, "Speech ended")
                recognitionActive = false
            }
            
            override fun onError(error: Int) {
                Log.e(TAG, "Recognition error: $error")
                recognitionActive = false
                
                // Restart recognition if still translating
                if (_isTranslating.value) {
                    CoroutineScope(Dispatchers.Main).launch {
                        delay(500)
                        startRecognitionCycle()
                    }
                }
            }
            
            override fun onResults(results: Bundle?) {
                val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                if (!matches.isNullOrEmpty()) {
                    val recognizedText = matches[0]
                    Log.d(TAG, "Recognized: $recognizedText")
                    
                    // Translate the recognized text
                    CoroutineScope(Dispatchers.Main).launch {
                        translateText(recognizedText)
                    }
                }
                recognitionActive = false
            }
            
            override fun onPartialResults(partialResults: Bundle?) {
                val partialMatches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                if (!partialMatches.isNullOrEmpty()) {
                    val partialText = partialMatches[0]
                    Log.d(TAG, "Partial: $partialText")
                    
                    // Update with partial translation
                    _currentTranslation.value = TranslationResult(
                        sourceText = partialText,
                        translatedText = "[Translating...] $partialText",
                        sourceLanguage = _sourceLanguage.value,
                        targetLanguage = _targetLanguage.value,
                        timestamp = System.currentTimeMillis(),
                        isPartial = true
                    )
                }
            }
            
            override fun onEvent(eventType: Int, params: Bundle?) {
                Log.d(TAG, "onEvent: $eventType")
            }
        })
        
        speechRecognizer?.startListening(recognizerIntent)
    }
    
    /**
     * Translate text using ML Kit
     */
    private suspend fun translateText(text: String) {
        if (text.isBlank()) return
        
        try {
            // Detect language if auto-detection is enabled
            val detectedLanguage = if (_sourceLanguage.value == "auto") {
                detectLanguage(text)
            } else {
                _sourceLanguage.value
            }
            
            // If source and target languages are the same, no translation needed
            if (detectedLanguage == _targetLanguage.value) {
                val result = TranslationResult(
                    sourceText = text,
                    translatedText = text,
                    sourceLanguage = detectedLanguage,
                    targetLanguage = _targetLanguage.value,
                    timestamp = System.currentTimeMillis(),
                    isPartial = false
                )
                updateTranslationResult(result)
                return
            }
            
            // Try Claude first for better quality translations
            val translatedText = try {
                if (AIServicesConfig.CLAUDE_API_KEY != "YOUR_CLAUDE_API_KEY") {
                    // Use Claude for high-quality translation
                    claudeAI.translateWithContext(
                        text = text,
                        sourceLanguage = detectedLanguage,
                        targetLanguage = _targetLanguage.value,
                        context = "Live speech translation"
                    )
                } else {
                    // Fall back to ML Kit translation
                    currentTranslator?.translate(text)?.await() ?: text
                }
            } catch (e: Exception) {
                Log.e(TAG, "Translation failed, using original text", e)
                text
            }
            
            val result = TranslationResult(
                sourceText = text,
                translatedText = translatedText,
                sourceLanguage = detectedLanguage,
                targetLanguage = _targetLanguage.value,
                timestamp = System.currentTimeMillis(),
                isPartial = false
            )
            
            updateTranslationResult(result)
            
        } catch (e: Exception) {
            Log.e(TAG, "Translation error", e)
        }
    }
    
    /**
     * Detect language of text
     */
    private suspend fun detectLanguage(text: String): String = suspendCoroutine { continuation ->
        val languageIdentifier = LanguageIdentification.getClient()
        
        languageIdentifier.identifyLanguage(text)
            .addOnSuccessListener { languageCode ->
                continuation.resume(
                    if (languageCode == "und") "en" else languageCode
                )
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "Language detection failed", e)
                continuation.resume("en")
            }
    }
    
    /**
     * Update translation result
     */
    private fun updateTranslationResult(result: TranslationResult) {
        _currentTranslation.value = result
        
        // Add to history if it's a final result
        if (!result.isPartial) {
            val currentHistory = _translationHistory.value.toMutableList()
            currentHistory.add(0, result) // Add to beginning
            
            // Keep only last 50 translations
            if (currentHistory.size > 50) {
                currentHistory.removeLast()
            }
            
            _translationHistory.value = currentHistory
        }
    }
    
    /**
     * Get locale string for language code
     */
    private fun getLocaleForLanguage(languageCode: String): String {
        return when (languageCode) {
            "en" -> "en-US"
            "es" -> "es-ES"
            "fr" -> "fr-FR"
            "de" -> "de-DE"
            "it" -> "it-IT"
            "pt" -> "pt-BR"
            "ru" -> "ru-RU"
            "zh" -> "zh-CN"
            "ja" -> "ja-JP"
            "ko" -> "ko-KR"
            "ar" -> "ar-SA"
            "hi" -> "hi-IN"
            else -> Locale.getDefault().toString()
        }
    }
    
    /**
     * Change source language
     */
    suspend fun setSourceLanguage(languageCode: String) {
        _sourceLanguage.value = languageCode
        
        // Restart translation if active
        if (_isTranslating.value) {
            stopLiveTranslation()
            delay(100)
            startLiveTranslation(languageCode, _targetLanguage.value)
        }
    }
    
    /**
     * Change target language
     */
    suspend fun setTargetLanguage(languageCode: String) {
        _targetLanguage.value = languageCode
        
        // Update translator
        if (_isTranslating.value) {
            stopLiveTranslation()
            delay(100)
            startLiveTranslation(_sourceLanguage.value, languageCode)
        }
    }
    
    /**
     * Clear translation history
     */
    fun clearHistory() {
        _translationHistory.value = emptyList()
    }
    
    /**
     * Export translation history
     */
    fun exportHistory(): String {
        val history = _translationHistory.value
        return buildString {
            append("Live Translation History\n")
            append("========================\n\n")
            
            history.forEach { result ->
                append("Time: ${Date(result.timestamp)}\n")
                append("From (${result.sourceLanguage}): ${result.sourceText}\n")
                append("To (${result.targetLanguage}): ${result.translatedText}\n")
                append("---\n\n")
            }
        }
    }
    
    /**
     * Release resources
     */
    fun release() {
        stopLiveTranslation()
        currentTranslator?.close()
        speechRecognizer?.destroy()
    }
}

data class TranslationResult(
    val sourceText: String,
    val translatedText: String,
    val sourceLanguage: String,
    val targetLanguage: String,
    val timestamp: Long,
    val isPartial: Boolean = false
)