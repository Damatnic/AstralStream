package com.astralplayer.nextplayer.data.database

import androidx.room.*
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.astralplayer.nextplayer.data.RecentFile
import kotlinx.coroutines.flow.Flow

// Enhanced entities for the database
@Entity(tableName = "recent_files")
data class RecentFileEntity(
    @PrimaryKey val id: String,
    val uri: String,
    val title: String,
    val duration: Long = 0L,
    val lastPosition: Long = 0L,
    val lastPlayedTime: Long = System.currentTimeMillis(),
    val thumbnailPath: String? = null,
    val fileSize: Long = 0L,
    val mimeType: String? = null,
    val isCloudFile: Boolean = false,
    val cloudProvider: String? = null,
    val cloudFileId: String? = null,
    val playCount: Int = 0,
    val isFavorite: Boolean = false,
    val tags: String = "", // JSON string of tags
    val metadata: String = "" // JSON string of additional metadata
)

@Entity(tableName = "playlists")
data class PlaylistEntity(
    @PrimaryKey val id: String,
    val name: String,
    val description: String = "",
    val createdTime: Long = System.currentTimeMillis(),
    val updatedTime: Long = System.currentTimeMillis(),
    val thumbnailPath: String? = null,
    val isAutoGenerated: Boolean = false,
    val sortOrder: Int = 0
)

@Entity(
    tableName = "playlist_items",
    foreignKeys = [
        ForeignKey(
            entity = PlaylistEntity::class,
            parentColumns = ["id"],
            childColumns = ["playlistId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = RecentFileEntity::class,
            parentColumns = ["id"],
            childColumns = ["fileId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("playlistId"), Index("fileId")]
)
data class PlaylistItemEntity(
    @PrimaryKey val id: String,
    val playlistId: String,
    val fileId: String,
    val position: Int,
    val addedTime: Long = System.currentTimeMillis()
)

@Entity(tableName = "subtitles")
data class SubtitleEntity(
    @PrimaryKey val id: String,
    val fileId: String, // References RecentFileEntity
    val language: String,
    val content: String, // SRT/VTT content
    val isAIGenerated: Boolean = false,
    val generationTime: Long = 0L,
    val translatedFrom: String? = null,
    val filePath: String? = null, // Local file path if saved
    val isEnabled: Boolean = true,
    val fontSize: Float = 16f,
    val fontColor: String = "#FFFFFF",
    val backgroundColor: String = "#80000000",
    val position: String = "bottom" // bottom, top, center
)

@Entity(tableName = "cloud_files")
data class CloudFileEntity(
    @PrimaryKey val id: String,
    val cloudProvider: String, // "google_drive", "dropbox", etc.
    val cloudFileId: String,
    val fileName: String,
    val filePath: String,
    val fileSize: Long,
    val mimeType: String,
    val createdTime: Long,
    val modifiedTime: Long,
    val downloadUrl: String? = null,
    val thumbnailUrl: String? = null,
    val isDownloaded: Boolean = false,
    val localPath: String? = null,
    val syncTime: Long = System.currentTimeMillis(),
    val metadata: String = "" // JSON metadata
)

@Entity(tableName = "download_queue")
data class DownloadQueueEntity(
    @PrimaryKey val id: String,
    val cloudFileId: String,
    val fileName: String,
    val fileSize: Long,
    val downloadUrl: String,
    val localPath: String,
    val status: String, // "pending", "downloading", "completed", "failed", "paused"
    val progress: Float = 0f,
    val downloadedBytes: Long = 0L,
    val createdTime: Long = System.currentTimeMillis(),
    val startedTime: Long? = null,
    val completedTime: Long? = null,
    val errorMessage: String? = null,
    val priority: Int = 0 // Higher number = higher priority
)

@Entity(tableName = "user_preferences")
data class UserPreferenceEntity(
    @PrimaryKey val key: String,
    val value: String,
    val type: String, // "string", "int", "float", "boolean", "json"
    val updatedTime: Long = System.currentTimeMillis()
)

@Entity(tableName = "playback_history")
data class PlaybackHistoryEntity(
    @PrimaryKey val id: String,
    val fileId: String,
    val startTime: Long,
    val endTime: Long? = null,
    val duration: Long,
    val position: Long,
    val completionPercentage: Float,
    val playbackSpeed: Float = 1.0f,
    val volume: Float = 1.0f,
    val subtitleLanguage: String? = null,
    val deviceInfo: String = "", // JSON device info
    val sessionData: String = "" // JSON session data
)

// DAOs
@Dao
interface RecentFilesDao {
    @Query("SELECT * FROM recent_files ORDER BY lastPlayedTime DESC")
    fun getAllRecentFiles(): Flow<List<RecentFileEntity>>
    
    @Query("SELECT * FROM recent_files WHERE id = :id")
    suspend fun getRecentFileById(id: String): RecentFileEntity?
    
    @Query("SELECT * FROM recent_files WHERE isFavorite = 1 ORDER BY lastPlayedTime DESC")
    fun getFavoriteFiles(): Flow<List<RecentFileEntity>>
    
    @Query("SELECT * FROM recent_files WHERE isCloudFile = 1 ORDER BY lastPlayedTime DESC")
    fun getCloudFiles(): Flow<List<RecentFileEntity>>
    
    @Query("SELECT * FROM recent_files WHERE title LIKE '%' || :query || '%' OR tags LIKE '%' || :query || '%'")
    fun searchFiles(query: String): Flow<List<RecentFileEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRecentFile(file: RecentFileEntity)
    
    @Update
    suspend fun updateRecentFile(file: RecentFileEntity)
    
    @Delete
    suspend fun deleteRecentFile(file: RecentFileEntity)
    
    @Query("DELETE FROM recent_files WHERE lastPlayedTime < :cutoffTime AND isFavorite = 0")
    suspend fun deleteOldFiles(cutoffTime: Long)
    
    @Query("UPDATE recent_files SET playCount = playCount + 1, lastPlayedTime = :time WHERE id = :id")
    suspend fun incrementPlayCount(id: String, time: Long = System.currentTimeMillis())
    
    @Query("UPDATE recent_files SET lastPosition = :position WHERE id = :id")
    suspend fun updateLastPosition(id: String, position: Long)
    
    @Query("SELECT * FROM recent_files WHERE uri = :uri LIMIT 1")
    suspend fun getRecentFileByUri(uri: String): RecentFileEntity?
}

@Dao
interface PlaylistDao {
    @Query("SELECT * FROM playlists ORDER BY sortOrder ASC, name ASC")
    fun getAllPlaylists(): Flow<List<PlaylistEntity>>
    
    @Query("SELECT * FROM playlists WHERE id = :id")
    suspend fun getPlaylistById(id: String): PlaylistEntity?
    
    @Query("""
        SELECT rf.* FROM recent_files rf
        INNER JOIN playlist_items pi ON rf.id = pi.fileId
        WHERE pi.playlistId = :playlistId
        ORDER BY pi.position ASC
    """)
    fun getPlaylistFiles(playlistId: String): Flow<List<RecentFileEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPlaylist(playlist: PlaylistEntity)
    
    @Update
    suspend fun updatePlaylist(playlist: PlaylistEntity)
    
    @Delete
    suspend fun deletePlaylist(playlist: PlaylistEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPlaylistItem(item: PlaylistItemEntity)
    
    @Query("DELETE FROM playlist_items WHERE playlistId = :playlistId AND fileId = :fileId")
    suspend fun removePlaylistItem(playlistId: String, fileId: String)
    
    @Query("SELECT COUNT(*) FROM playlist_items WHERE playlistId = :playlistId")
    suspend fun getPlaylistItemCount(playlistId: String): Int
    
    @Query("SELECT position FROM playlist_items WHERE playlistId = :playlistId AND fileId = :fileId")
    suspend fun getVideoPosition(playlistId: String, fileId: String): Int?
    
    @Query("UPDATE playlist_items SET position = :newPosition WHERE playlistId = :playlistId AND fileId = :fileId")
    suspend fun updateVideoPosition(playlistId: String, fileId: String, newPosition: Int)
    
    @Query("UPDATE playlist_items SET position = position + 1 WHERE playlistId = :playlistId AND position >= :fromPosition AND position < :toPosition")
    suspend fun shiftPositionsDown(playlistId: String, fromPosition: Int, toPosition: Int)
    
    @Query("UPDATE playlist_items SET position = position - 1 WHERE playlistId = :playlistId AND position > :fromPosition AND position <= :toPosition")
    suspend fun shiftPositionsUp(playlistId: String, fromPosition: Int, toPosition: Int)
}

@Dao
interface SubtitleDao {
    @Query("SELECT * FROM subtitles WHERE fileId = :fileId ORDER BY language ASC")
    fun getSubtitlesForFile(fileId: String): Flow<List<SubtitleEntity>>
    
    @Query("SELECT * FROM subtitles WHERE id = :id")
    suspend fun getSubtitleById(id: String): SubtitleEntity?
    
    @Query("SELECT * FROM subtitles WHERE fileId = :fileId AND language = :language")
    suspend fun getSubtitleByLanguage(fileId: String, language: String): SubtitleEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSubtitle(subtitle: SubtitleEntity)
    
    @Update
    suspend fun updateSubtitle(subtitle: SubtitleEntity)
    
    @Delete
    suspend fun deleteSubtitle(subtitle: SubtitleEntity)
    
    @Query("DELETE FROM subtitles WHERE fileId = :fileId")
    suspend fun deleteSubtitlesForFile(fileId: String)
    
    @Query("DELETE FROM subtitles WHERE isAIGenerated = 1 AND generationTime < :cutoffTime")
    suspend fun deleteOldAISubtitles(cutoffTime: Long)
}

@Dao
interface CloudFileDao {
    @Query("SELECT * FROM cloud_files WHERE cloudProvider = :provider ORDER BY modifiedTime DESC")
    fun getCloudFilesByProvider(provider: String): Flow<List<CloudFileEntity>>
    
    @Query("SELECT * FROM cloud_files WHERE isDownloaded = 1")
    fun getDownloadedFiles(): Flow<List<CloudFileEntity>>
    
    @Query("SELECT * FROM cloud_files WHERE id = :id")
    suspend fun getCloudFileById(id: String): CloudFileEntity?
    
    @Query("SELECT * FROM cloud_files WHERE cloudFileId = :cloudFileId AND cloudProvider = :provider")
    suspend fun getCloudFileByProviderAndId(provider: String, cloudFileId: String): CloudFileEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCloudFile(file: CloudFileEntity)
    
    @Update
    suspend fun updateCloudFile(file: CloudFileEntity)
    
    @Delete
    suspend fun deleteCloudFile(file: CloudFileEntity)
    
    @Query("UPDATE cloud_files SET isDownloaded = 1, localPath = :localPath WHERE id = :id")
    suspend fun markAsDownloaded(id: String, localPath: String)
    
    @Query("DELETE FROM cloud_files WHERE syncTime < :cutoffTime")
    suspend fun deleteOldSyncData(cutoffTime: Long)
}

@Dao
interface DownloadQueueDao {
    @Query("SELECT * FROM download_queue ORDER BY priority DESC, createdTime ASC")
    fun getAllDownloads(): Flow<List<DownloadQueueEntity>>
    
    @Query("SELECT * FROM download_queue WHERE status = :status ORDER BY priority DESC, createdTime ASC")
    fun getDownloadsByStatus(status: String): Flow<List<DownloadQueueEntity>>
    
    @Query("SELECT * FROM download_queue WHERE id = :id")
    suspend fun getDownloadById(id: String): DownloadQueueEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertDownload(download: DownloadQueueEntity)
    
    @Update
    suspend fun updateDownload(download: DownloadQueueEntity)
    
    @Delete
    suspend fun deleteDownload(download: DownloadQueueEntity)
    
    @Query("UPDATE download_queue SET status = :status, progress = :progress, downloadedBytes = :downloadedBytes WHERE id = :id")
    suspend fun updateDownloadProgress(id: String, status: String, progress: Float, downloadedBytes: Long)
    
    @Query("DELETE FROM download_queue WHERE status = 'completed' AND completedTime < :cutoffTime")
    suspend fun deleteCompletedDownloads(cutoffTime: Long)
}

@Dao
interface UserPreferenceDao {
    @Query("SELECT * FROM user_preferences")
    fun getAllPreferences(): Flow<List<UserPreferenceEntity>>
    
    @Query("SELECT * FROM user_preferences WHERE key = :key")
    suspend fun getPreference(key: String): UserPreferenceEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun setPreference(preference: UserPreferenceEntity)
    
    @Query("DELETE FROM user_preferences WHERE key = :key")
    suspend fun deletePreference(key: String)
}

@Dao
interface PlaybackHistoryDao {
    @Query("SELECT * FROM playback_history ORDER BY startTime DESC LIMIT :limit")
    fun getRecentHistory(limit: Int = 100): Flow<List<PlaybackHistoryEntity>>
    
    @Query("SELECT * FROM playback_history WHERE fileId = :fileId ORDER BY startTime DESC")
    fun getHistoryForFile(fileId: String): Flow<List<PlaybackHistoryEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertHistory(history: PlaybackHistoryEntity)
    
    @Query("DELETE FROM playback_history WHERE startTime < :cutoffTime")
    suspend fun deleteOldHistory(cutoffTime: Long)
    
    @Query("SELECT AVG(completionPercentage) FROM playback_history WHERE fileId = :fileId")
    suspend fun getAverageCompletionForFile(fileId: String): Float?
}

// Database migrations
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add new columns to existing tables
        database.execSQL("ALTER TABLE recent_files ADD COLUMN isCloudFile INTEGER NOT NULL DEFAULT 0")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN cloudProvider TEXT")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN cloudFileId TEXT")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN playCount INTEGER NOT NULL DEFAULT 0")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN isFavorite INTEGER NOT NULL DEFAULT 0")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN tags TEXT NOT NULL DEFAULT ''")
        database.execSQL("ALTER TABLE recent_files ADD COLUMN metadata TEXT NOT NULL DEFAULT ''")
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create new tables
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS playlists (
                id TEXT PRIMARY KEY NOT NULL,
                name TEXT NOT NULL,
                description TEXT NOT NULL DEFAULT '',
                createdTime INTEGER NOT NULL DEFAULT 0,
                updatedTime INTEGER NOT NULL DEFAULT 0,
                thumbnailPath TEXT,
                isAutoGenerated INTEGER NOT NULL DEFAULT 0,
                sortOrder INTEGER NOT NULL DEFAULT 0
            )
        """)
        
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS playlist_items (
                id TEXT PRIMARY KEY NOT NULL,
                playlistId TEXT NOT NULL,
                fileId TEXT NOT NULL,
                position INTEGER NOT NULL,
                addedTime INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(playlistId) REFERENCES playlists(id) ON DELETE CASCADE,
                FOREIGN KEY(fileId) REFERENCES recent_files(id) ON DELETE CASCADE
            )
        """)
        
        database.execSQL("CREATE INDEX IF NOT EXISTS index_playlist_items_playlistId ON playlist_items(playlistId)")
        database.execSQL("CREATE INDEX IF NOT EXISTS index_playlist_items_fileId ON playlist_items(fileId)")
    }
}

val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create subtitles table
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS subtitles (
                id TEXT PRIMARY KEY NOT NULL,
                fileId TEXT NOT NULL,
                language TEXT NOT NULL,
                content TEXT NOT NULL,
                isAIGenerated INTEGER NOT NULL DEFAULT 0,
                generationTime INTEGER NOT NULL DEFAULT 0,
                translatedFrom TEXT,
                filePath TEXT,
                isEnabled INTEGER NOT NULL DEFAULT 1,
                fontSize REAL NOT NULL DEFAULT 16.0,
                fontColor TEXT NOT NULL DEFAULT '#FFFFFF',
                backgroundColor TEXT NOT NULL DEFAULT '#80000000',
                position TEXT NOT NULL DEFAULT 'bottom'
            )
        """)
    }
}

val MIGRATION_4_5 = object : Migration(4, 5) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create cloud and download tables
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS cloud_files (
                id TEXT PRIMARY KEY NOT NULL,
                cloudProvider TEXT NOT NULL,
                cloudFileId TEXT NOT NULL,
                fileName TEXT NOT NULL,
                filePath TEXT NOT NULL,
                fileSize INTEGER NOT NULL,
                mimeType TEXT NOT NULL,
                createdTime INTEGER NOT NULL,
                modifiedTime INTEGER NOT NULL,
                downloadUrl TEXT,
                thumbnailUrl TEXT,
                isDownloaded INTEGER NOT NULL DEFAULT 0,
                localPath TEXT,
                syncTime INTEGER NOT NULL DEFAULT 0,
                metadata TEXT NOT NULL DEFAULT ''
            )
        """)
        
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS download_queue (
                id TEXT PRIMARY KEY NOT NULL,
                cloudFileId TEXT NOT NULL,
                fileName TEXT NOT NULL,
                fileSize INTEGER NOT NULL,
                downloadUrl TEXT NOT NULL,
                localPath TEXT NOT NULL,
                status TEXT NOT NULL,
                progress REAL NOT NULL DEFAULT 0.0,
                downloadedBytes INTEGER NOT NULL DEFAULT 0,
                createdTime INTEGER NOT NULL DEFAULT 0,
                startedTime INTEGER,
                completedTime INTEGER,
                errorMessage TEXT,
                priority INTEGER NOT NULL DEFAULT 0
            )
        """)
    }
}

val MIGRATION_5_6 = object : Migration(5, 6) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create preferences and history tables
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS user_preferences (
                key TEXT PRIMARY KEY NOT NULL,
                value TEXT NOT NULL,
                type TEXT NOT NULL,
                updatedTime INTEGER NOT NULL DEFAULT 0
            )
        """)
        
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS playback_history (
                id TEXT PRIMARY KEY NOT NULL,
                fileId TEXT NOT NULL,
                startTime INTEGER NOT NULL,
                endTime INTEGER,
                duration INTEGER NOT NULL,
                position INTEGER NOT NULL,
                completionPercentage REAL NOT NULL,
                playbackSpeed REAL NOT NULL DEFAULT 1.0,
                volume REAL NOT NULL DEFAULT 1.0,
                subtitleLanguage TEXT,
                deviceInfo TEXT NOT NULL DEFAULT '',
                sessionData TEXT NOT NULL DEFAULT ''
            )
        """)
    }
}

// Main Database class
@Database(
    entities = [
        RecentFileEntity::class,
        PlaylistEntity::class,
        PlaylistItemEntity::class,
        SubtitleEntity::class,
        CloudFileEntity::class,
        DownloadQueueEntity::class,
        UserPreferenceEntity::class,
        PlaybackHistoryEntity::class
    ],
    version = 6,
    exportSchema = true
)
abstract class AstralVuDatabase : RoomDatabase() {
    abstract fun recentFilesDao(): RecentFilesDao
    abstract fun playlistDao(): PlaylistDao
    abstract fun subtitleDao(): SubtitleDao
    abstract fun cloudFileDao(): CloudFileDao
    abstract fun downloadQueueDao(): DownloadQueueDao
    abstract fun userPreferenceDao(): UserPreferenceDao
    abstract fun playbackHistoryDao(): PlaybackHistoryDao
    
    companion object {
        const val DATABASE_NAME = "astral_vu_database"
        
        fun getAllMigrations(): Array<Migration> {
            return arrayOf(
                MIGRATION_1_2,
                MIGRATION_2_3,
                MIGRATION_3_4,
                MIGRATION_4_5,
                MIGRATION_5_6
            )
        }
    }
}

